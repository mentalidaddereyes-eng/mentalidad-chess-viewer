<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Visor PGN â€” Tablero interactivo + anÃ¡lisis</title>
<meta name="description" content="Visor PGN con tablero interactivo, anÃ¡lisis Stockfish y modos NiÃ±os/Adultos. Responsive para mÃ³vil y desktop.">

<script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.12.0/chess.min.js"></script>

<style>
Â  :root{
Â  Â  /* Paleta de colores mejorada con variables claras */
Â  Â  --bg: #0c1422; 
Â  Â  --panel: #0f1b2e; 
Â  Â  --borde: #232a36; 
Â  Â  --txt: #e6edf3; 
Â  Â  --muted: #9fb0c3;
Â  Â  --sq-light: #e8f3e5; 
Â  Â  --sq-dark: #69a24a; /* Por defecto (NiÃ±os) */
Â  Â  --btn: #24324a; 
Â  Â  --btnbd: #3b4a63; 
Â  Â  --btnh: #2b3f5e; 
Â  Â  --ok: #22c55e;
Â  Â  --hl-last: rgba(255, 225, 0, 0.28);
Â  Â  --hl-select: rgba(255, 255, 255, 0.2); /* Nuevo para casilla seleccionada */
Â  Â  --hl-move: rgba(255, 255, 255, 0.1); /* Nuevo para movimientos posibles */
Â  }
Â  *{box-sizing:border-box}
Â  html,body{height:100%}
Â  body{margin:0;background:var(--bg);color:var(--txt);font:16px/1.4 Inter,system-ui,Segoe UI,Roboto,Arial}

Â  h1{max-width:1100px;margin:14px auto 6px;padding:0 16px;font-size:24px}
Â  .wrap{max-width:1100px;margin:0 auto;padding:12px 16px}
Â  .grid{display:grid;gap:14px;grid-template-columns:1fr 380px}
Â  @media (max-width:980px){.grid{grid-template-columns:1fr}}
Â  .panel{background:var(--panel);border:1px solid var(--borde);border-radius:14px;padding:12px}

Â  #canvasBox{width:100%;max-width:900px;margin:auto}
Â  canvas{
Â  Â  width:100%;height:auto;display:block;border:1px solid var(--borde);
Â  Â  border-radius:10px;background:transparent;outline:none;touch-action:none;
Â  }
Â  .status{margin-top:6px;color:var(--ok);font-size:14px;min-height:20px} /* Altura mÃ­nima para evitar saltos */

Â  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
Â  button{
Â  Â  background:var(--btn);border:1px solid var(--btnbd);color:var(--txt);
Â  Â  border-radius:10px;padding:9px 13px;cursor:pointer;
Â  Â  font-family:inherit; /* Asegurar que use la fuente principal */
Â  Â  font-size:inherit;
Â  Â  line-height:1; /* Mejor manejo de la altura del botÃ³n */
Â  }
Â  button:hover{background:var(--btnh)}
Â  .primary{background:#2f7d4e;border-color:#2f7d4e}
Â  .ghost{background:transparent;border-color:var(--borde)}
Â  .chip{padding:6px 10px;border-radius:8px;border:1px solid var(--borde);background:#0b1627}
Â  input,select,textarea{font:inherit}
Â  input[type="number"]{
Â  Â  width:92px;background:#0b1627;border:1px solid var(--borde);border-radius:8px;
Â  Â  padding:8px;color:var(--txt);appearance:textfield; /* Ocultar flechas en Firefox */
Â  }
Â  /* Ocultar flechas en Chrome/Safari */
Â  input::-webkit-outer-spin-button, input::-webkit-inner-spin-button {
Â  Â  -webkit-appearance: none; margin: 0;
Â  }
Â  textarea{width:100%;min-height:140px;background:#0b1627;border:1px solid var(--borde);border-radius:10px;padding:10px;color:var(--txt);resize:vertical;white-space:pre-wrap}
Â  .box{background:#0b1627;border:1px solid var(--borde);border-radius:10px;padding:10px}
Â  .mono{font-family:ui-monospace,Menlo,Consolas,monospace;white-space:pre-wrap}
Â  .note{color:var(--muted);font-size:14px}
Â  .bar{height:6px;border-radius:999px;background:#122034;overflow:hidden}
Â  .bar > i{display:block;height:100%;background:linear-gradient(90deg,#2dd4bf,#22c55e);width:0%}

Â  #file{display:none}
Â  label[for="file"]{display:inline-flex;align-items:center;gap:8px;cursor:pointer}
Â  label[for="file"]::before{content:"ğŸ“‚"}
Â  #gamePicker{display:none;margin-top:6px}

Â  #promo{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.45);z-index:40}
Â  #promo .card{background:#0f1b2e;border:1px solid var(--borde);padding:14px;border-radius:12px}
Â  #promo .card h3{margin:0 0 8px 0;font-size:16px}
Â  #promo .choices{display:flex;gap:8px}
Â  #promo button{font-size:24px;padding:8px 12px}

Â  body.kids { --sq-light:#e8f3e5; --sq-dark:#69a24a; }
Â  body.adult{ --sq-light:#f0d9b5; --sq-dark:#b58863; }
Â  body.kids .mono { font-size: 15px; }
Â  body.kids button { transform: translateZ(0); transition: transform .05s; }
Â  body.kids button:active { transform: scale(0.98); }

Â  @media (max-width:600px){
Â  Â  button{padding:12px 14px}
Â  Â  .chip{padding:8px 12px}
Â  Â  #canvasBox{max-width:100vw}
Â  Â  h1{font-size:20px}
Â  }
/* === AJUSTE DE PANTALLA Y PANEL DERECHO === */
body.compact .grid{ grid-template-columns: 1fr; }
body.compact .grid > .panel:nth-child(2){ display: none; }

@media (min-width: 981px){
Â  .grid > .panel:nth-child(2){
Â  Â  max-height: calc(100vh - 140px);
Â  Â  overflow: auto;
Â  }
}
Â  </style>
</head>
<body>
Â  <h1>Visor PGN â€” tablero interactivo + anÃ¡lisis</h1>

Â  <div class="wrap grid">
Â  Â  Â  Â  <div class="panel">
Â  Â  Â  <div id="canvasBox"><canvas id="board" width="720" height="720" tabindex="0"></canvas></div>

Â  Â  Â  <div class="row" style="margin-top:10px">
Â  Â  Â  Â  <button id="prevBtn" class="ghost" aria-label="Anterior movimiento">â† Anterior</button>
Â  Â  Â  Â  <button id="playBtn" class="primary" aria-label="Reproducir movimientos">â–¶ Play</button>
Â  Â  Â  Â  <button id="nextBtn" class="ghost" aria-label="Siguiente movimiento">Siguiente â†’</button>
Â  Â  Â  Â  <button id="resetBtn" class="ghost" aria-label="Reiniciar partida">Reiniciar</button>
Â  Â  Â  Â  <label class="chip">Velocidad <input id="speed" type="number" value="800" min="100" step="50" aria-label="Velocidad de reproducciÃ³n en milisegundos"></label>
Â  Â  Â  Â  <label class="chip"><input id="auto" type="checkbox" checked> Auto-analizar</label>
Â  Â  Â  </div>

Â  Â  Â  <div id="status" class="status">Cargandoâ€¦</div>
Â  Â  </div>

Â  Â  Â  Â  <div class="panel">
Â  Â  Â  <div class="row" style="margin-bottom:8px">
Â  Â  Â  Â  <label class="chip">Modo:
Â  Â  Â  Â  Â  <select id="modeSel" aria-label="Seleccionar modo de visualizaciÃ³n">
Â  Â  Â  Â  Â  Â  <option value="kids">NiÃ±os</option>
Â  Â  Â  Â  Â  Â  <option value="adult">Adultos</option>
Â  Â  Â  Â  Â  </select>
Â  Â  Â  Â  </label>
Â  Â  Â  </div>

Â  Â  Â  <div class="row">
Â  Â  Â  Â  <label for="file" class="primary">Abrir PGN</label>
Â  Â  Â  Â  <input id="file" type="file" accept=".pgn,.txt" aria-label="Abrir archivo PGN o TXT">
Â  Â  Â  Â  <button id="copyFenBtn" class="ghost" aria-label="Copiar FEN (NotaciÃ³n Forsyth-Edwards)">Copiar FEN</button>
Â  Â  Â  </div>

Â  Â  Â  <div id="gamePicker" class="row">
Â  Â  Â  Â  <span class="note">Partidas en el archivo:</span>
Â  Â  Â  Â  <select id="gameSelect" class="chip" aria-label="Seleccionar partida"></select>
Â  Â  Â  Â  <span id="gameCount" class="note"></span>
Â  Â  Â  </div>

Â  Â  Â  <div class="note" style="margin:10px 0 4px">O pega PGN aquÃ­ (opcional) y pulsa â€œImportarâ€:</div>
Â  Â  Â  <textarea id="pgnText" placeholder="(Opcional) Pega tu PGN aquÃ­â€¦" aria-label="Caja de texto para PGN"></textarea>
Â  Â  Â  <div class="row" style="margin-top:8px">
Â  Â  Â  Â  <button id="loadTextBtn" class="primary" aria-label="Importar PGN desde texto">Importar</button>
Â  Â  Â  Â  <span id="gameInfo" class="note">Sin partida cargada.</span>
Â  Â  Â  </div>

Â  Â  Â  <div id="movesBox" class="box mono" style="margin-top:8px;min-height:56px" aria-live="polite">Movidas aparecerÃ¡n aquÃ­â€¦</div>

Â  Â  Â  <div class="row" style="margin-top:12px">
Â  Â  Â  Â  <span class="note">AnÃ¡lisis Stockfish</span>
Â  Â  Â  Â  <div class="bar" style="flex:1"><i id="depthBar" style="width:0%"></i></div>
Â  Â  Â  </div>

Â  Â  Â  <div class="row" style="gap:12px;margin-top:8px">
Â  Â  Â  Â  <label class="chip">Profundidad mÃ¡x: <input id="maxDepth" type="number" min="6" max="30" value="18" aria-label="Profundidad mÃ¡xima de anÃ¡lisis"></label>
Â  Â  Â  Â  <label class="chip">LÃ­neas: <input id="multipv" type="number" min="1" max="3" value="1" aria-label="NÃºmero de lÃ­neas de anÃ¡lisis"></label>
Â  Â  Â  Â  <button id="goBtn" class="primary" aria-label="Iniciar anÃ¡lisis Stockfish">Analizar</button>
Â  Â  Â  Â  <button id="stopBtn" class="ghost" aria-label="Detener anÃ¡lisis">Detener</button>
Â  Â  Â  </div>

Â  Â  Â  <div id="evalBox" class="box" style="margin-top:8px" aria-live="polite">Eval: â€” | Profundidad: â€” | Mejor jugada: â€” <span id="engineSrc" class="note"></span></div>
Â  Â  Â  <div id="pvBox" class="box mono" style="margin-top:8px" aria-live="polite">LÃ­neas aparecerÃ¡n aquÃ­â€¦</div>
Â  Â  </div>
Â  </div>

Â  Â  <div id="promo" role="dialog" aria-modal="true" aria-labelledby="promo-title">
Â  Â  <div class="card">
Â  Â  Â  <h3 id="promo-title">Elige pieza de promociÃ³n</h3>
Â  Â  Â  <div class="choices">
Â  Â  Â  Â  <button data-p="q" aria-label="Promocionar a Reina">â™•</button>
Â  Â  Â  Â  <button data-p="r" aria-label="Promocionar a Torre">â™–</button>
Â  Â  Â  Â  <button data-p="b" aria-label="Promocionar a Alfil">â™—</button>
Â  Â  Â  Â  <button data-p="n" aria-label="Promocionar a Caballo">â™˜</button>
Â  Â  Â  </div>
Â  Â  </div>
Â  </div>

<script>
// El cÃ³digo JS se ha movido aquÃ­ para una mejor separaciÃ³n y modularizaciÃ³n
(function(){
Â  "use strict";

Â  // ===== Constantes y Elementos del DOM
Â  const GLYPH = {'P':'â™™','N':'â™˜','B':'â™—','R':'â™–','Q':'â™•','K':'â™”','p':'â™Ÿ','n':'â™','b':'â™','r':'â™œ','q':'â™›','k':'â™š'};
Â  const canvas = document.getElementById('board');
Â  const ctx = canvas.getContext('2d', {alpha:true});
Â  const statusEl = document.getElementById('status');
Â  const promo = document.getElementById('promo');
Â  const modeSel = document.getElementById('modeSel');
Â  const auto = document.getElementById('auto');

Â  // Elementos de Control y PGN
Â  const prevBtn = document.getElementById('prevBtn');
Â  const nextBtn = document.getElementById('nextBtn');
Â  const resetBtn = document.getElementById('resetBtn');
Â  const playBtn = document.getElementById('playBtn');
Â  const file = document.getElementById('file');
Â  const pgnText = document.getElementById('pgnText');
Â  const loadTextBtn = document.getElementById('loadTextBtn');
Â  const copyFenBtn = document.getElementById('copyFenBtn');
Â  const gameSelect = document.getElementById('gameSelect');
Â  const goBtn = document.getElementById('goBtn');
Â  const stopBtn = document.getElementById('stopBtn');
Â  const maxDepthInput = document.getElementById('maxDepth');
Â  const multipvInput = document.getElementById('multipv');
Â  const depthBar = document.getElementById('depthBar');
Â  const movesBox = document.getElementById('movesBox');
Â  const gameInfoEl = document.getElementById('gameInfo');

Â  // Verifica chess.js
Â  if (typeof Chess !== 'function') {
Â  Â  statusEl.textContent = 'Error: no se pudo cargar chess.js. Revisa tu internet o el CDN.';
Â  Â  return;
Â  }

Â  // ===== Estado Global
Â  const game = new Chess();
Â  let frames = [game.fen()]; 
Â  let idx = 0;
Â  let playing = false; 
Â  let timer = null;
Â  let selSquare = null; 
Â  let drag = null;
Â  let lastMove = null; 
Â  let bestArrow = null;
Â  let possibleMoves = []; // Nuevo: para visualizaciÃ³n de movimientos posibles

Â  // ===== Helpers
Â  function cssVar(name){return getComputedStyle(document.documentElement).getPropertyValue(name).trim();}
Â  function statusMsg(t){ statusEl.textContent=t; }
Â  function dpr(){ return Math.max(1, Math.min(3, window.devicePixelRatio || 1)); }
Â  
Â  function alg2rc(sq){ 
Â  Â  if(!sq || sq.length !== 2) return null;
Â  Â  return {c: sq.charCodeAt(0)-97, r: 8-parseInt(sq[1],10)} 
Â  }
Â  function rc2alg(r,c){ 
Â  Â  if(r < 0 || r > 7 || c < 0 || c > 7) return null;
Â  Â  return String.fromCharCode(97+c)+(8-r) 
Â  }
Â  function getSquareFromEvent(ev){
Â  Â  const rect = canvas.getBoundingClientRect();
Â  Â  const clientX = ev.touches ? ev.touches[0].clientX : ev.clientX;
Â  Â  const clientY = ev.touches ? ev.touches[0].clientY : ev.clientY;

Â  Â  const cx = clientX - rect.left;
Â  Â  const cy = clientY - rect.top;
Â  Â  
Â  Â  const file = Math.min(7, Math.max(0, Math.floor(cx/rect.width*8)));
Â  Â  const rank = Math.min(7, Math.max(0, Math.floor(cy/rect.height*8)));
Â  Â  
Â  Â  const x = cx/rect.width * canvas.width;
Â  Â  const y = cy/rect.height * canvas.height;
Â  Â  
Â  Â  return {r:rank, c:file, x, y};
Â  }

Â  // ===== Responsive / Retina
Â  function targetBoardCSSpx(){
Â  Â  const box = document.getElementById('canvasBox');
Â  Â  const maxW = box.clientWidth || window.innerWidth;
Â  Â  // Estimar el espacio necesario para los controles
Â  Â  const isNarrow = window.innerWidth <= 600;
Â  Â  const reservedY = isNarrow ? 360 : 260; 
Â  Â  const vhRoom = Math.max(300, window.innerHeight - reservedY);
Â  Â  let size = Math.min(maxW, vhRoom);
Â  Â  size = Math.max(300, Math.min(size, 720));
Â  Â  return Math.round(size);
Â  }
Â  function resizeBoard(){
Â  Â  const css = targetBoardCSSpx();
Â  Â  const scale = dpr();
Â  Â  canvas.style.width = css + 'px';
Â  Â  canvas.style.height = css + 'px';
Â  Â  canvas.widthÂ  = Math.round(css * scale);
Â  Â  canvas.height = Math.round(css * scale);
Â  Â  render();
Â  }
Â  window.addEventListener('resize', resizeBoard);
Â  window.addEventListener('orientationchange', resizeBoard);

Â  // ===== Modo
Â  function applyMode(m){
Â  Â  document.body.classList.remove('kids','adult');
Â  Â  document.body.classList.add(m);
Â  Â  statusMsg(m==='kids' ? 'Â¡Listo para jugar! ğŸŒŸ Arrastra o toca para mover.' : 'Tablero listo. Arrastra o haz click-click para mover.');
Â  Â  render();
Â  }
Â  modeSel.onchange = ()=>applyMode(modeSel.value);
Â  applyMode('kids'); // Inicializar

Â  // ===== Dibujo (Refactorizado)
Â  function cellSize(){ return canvas.width / 8; }

Â  function drawBoard(fenPieces){
Â  Â  const S = cellSize();
Â  Â  const light = cssVar('--sq-light'), dark = cssVar('--sq-dark');
Â  Â  const highlightLast = cssVar('--hl-last');
Â  Â  const highlightSelect = cssVar('--hl-select');
Â  Â  const highlightMove = cssVar('--hl-move');

Â  Â  ctx.clearRect(0, 0, canvas.width, canvas.height); // Limpiar fondo

Â  Â  // 1. Cuadrados de fondo
Â  Â  for(let r=0;r<8;r++){
Â  Â  Â  for(let c=0;c<8;c++){
Â  Â  Â  Â  ctx.fillStyle = ((r+c)%2===0) ? light : dark;
Â  Â  Â  Â  ctx.fillRect(c*S, r*S, S, S);
Â  Â  Â  }
Â  Â  }

Â  Â  // 2. Resaltados
Â  Â  // Ãšltimo movimiento
Â  Â  if(lastMove){
Â  Â  Â  const a=alg2rc(lastMove.from), b=alg2rc(lastMove.to);
Â  Â  Â  ctx.fillStyle=highlightLast;
Â  Â  Â  ctx.fillRect(a.c*S,a.r*S,S,S);
Â  Â  Â  ctx.fillRect(b.c*S,b.r*S,S,S);
Â  Â  }

Â  Â  // Casilla seleccionada
Â  Â  if(selSquare){
Â  Â  Â  const sqPos = alg2rc(selSquare);
Â  Â  Â  if(sqPos){
Â  Â  Â  Â  ctx.fillStyle = highlightSelect;
Â  Â  Â  Â  ctx.fillRect(sqPos.c*S, sqPos.r*S, S, S);
Â  Â  Â  }
Â  Â  Â  // Movimientos posibles
Â  Â  Â  ctx.fillStyle = highlightMove;
Â  Â  Â  possibleMoves.forEach(move => {
Â  Â  Â  Â  const target = alg2rc(move.to);
Â  Â  Â  Â  if(target){
Â  Â  Â  Â  Â  const isCapture = game.get(move.to);
Â  Â  Â  Â  Â  ctx.beginPath();
Â  Â  Â  Â  Â  if (isCapture) {
Â  Â  Â  Â  Â  Â  // Un cÃ­rculo que bordea la casilla capturada
Â  Â  Â  Â  Â  Â  ctx.lineWidth = S * 0.15;
Â  Â  Â  Â  Â  Â  ctx.strokeStyle = highlightMove.replace(/, \d\.\d+\)/, ', 0.6)'); // MÃ¡s opaco
Â  Â  Â  Â  Â  Â  ctx.arc((target.c + 0.5) * S, (target.r + 0.5) * S, S * 0.45, 0, 2 * Math.PI);
Â  Â  Â  Â  Â  Â  ctx.stroke();
Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  // Un punto en el centro de la casilla vacÃ­a
Â  Â  Â  Â  Â  Â  ctx.arc((target.c + 0.5) * S, (target.r + 0.5) * S, S * 0.15, 0, 2 * Math.PI);
Â  Â  Â  Â  Â  Â  ctx.fill();
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  });
Â  Â  }

Â  Â  // 3. Flecha de mejor jugada (anÃ¡lisis)
Â  Â  if(bestArrow) drawArrow(bestArrow.from, bestArrow.to, 'rgba(28,199,86,.9)');

Â  Â  // 4. Piezas
Â  Â  const rows = fenPieces.split('/');
Â  Â  ctx.textAlign='center'; ctx.textBaseline='middle';
Â  Â  ctx.font = `${S*0.74}px "Segoe UI Symbol","Noto Color Emoji","Apple Color Emoji",serif`;
Â  Â  
Â  Â  for(let r=0;r<8;r++){
Â  Â  Â  let f=0;
Â  Â  Â  for(const ch of rows[r]){
Â  Â  Â  Â  if(/\d/.test(ch)){ 
Â  Â  Â  Â  Â  f += +ch; 
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  if(drag && rc2alg(r,f) === drag.from) { 
Â  Â  Â  Â  Â  Â  f++; continue; // Omitir la pieza que se estÃ¡ arrastrando
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  const x=(f+0.5)*S, y=(r+0.5)*S;
Â  Â  Â  Â  Â  const lightSq = (r+f)%2===0;
Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  ctx.lineWidth = S*0.06;
Â  Â  Â  Â  Â  ctx.strokeStyle = lightSq? 'rgba(0,0,0,.85)' : 'rgba(255,255,255,.9)';
Â  Â  Â  Â  Â  ctx.shadowColor='rgba(0,0,0,.35)'; ctx.shadowBlur=S*0.05;
Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  // Dibujar borde (stroke)
Â  Â  Â  Â  Â  ctx.strokeText(GLYPH[ch]||'', x, y); 
Â  Â  Â  Â  Â  ctx.shadowBlur=0;
Â  Â  Â  Â  Â  
Â  Â  Â  Â  Â  // Dibujar cuerpo (fill)
Â  Â  Â  Â  Â  ctx.fillStyle = /[PRNBQK]/.test(ch)? '#ffffff' : '#0b1120';
Â  Â  Â  Â  Â  ctx.fillText(GLYPH[ch]||'', x, y);
Â  Â  Â  Â  Â  f++;
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  }
Â  Â  
Â  Â  // 5. Pieza arrastrada (Ãºltimo para que estÃ© encima)
Â  Â  if(drag){
Â  Â  Â  const {piece,x,y}=drag;
Â  Â  Â  // Se mantiene el estilo de dibujo para drag
Â  Â  Â  ctx.lineWidth=S*0.06; ctx.strokeStyle='rgba(0,0,0,.85)';
Â  Â  Â  ctx.shadowColor='rgba(0,0,0,.35)'; ctx.shadowBlur=S*0.05;
Â  Â  Â  ctx.strokeText(GLYPH[piece]||'', x, y); ctx.shadowBlur=0;
Â  Â  Â  ctx.fillStyle=/[PRNBQK]/.test(piece)? '#ffffff' : '#0b1120';
Â  Â  Â  ctx.fillText(GLYPH[piece]||'', x, y);
Â  Â  }
Â  }

Â  function drawArrow(fromSq,toSq,color){
Â  Â  const S = cellSize();
Â  Â  const a=alg2rc(fromSq), b=alg2rc(toSq);
Â  Â  if(!a || !b) return;
Â  Â  const A={x:(a.c+0.5)*S,y:(a.r+0.5)*S}, B={x:(b.c+0.5)*S,y:(b.r+0.5)*S};
Â  Â  // Flecha
Â  Â  ctx.strokeStyle=color; ctx.lineWidth=Math.max(4,S*0.06); ctx.lineCap='round';
Â  Â  ctx.beginPath(); ctx.moveTo(A.x,A.y); ctx.lineTo(B.x,B.y); ctx.stroke();
Â  Â  // Cabeza de flecha
Â  Â  const ang=Math.atan2(B.y-A.y,B.x-A.x), L=Math.max(18,S*0.35);
Â  Â  ctx.beginPath(); ctx.moveTo(B.x,B.y);
Â  Â  ctx.lineTo(B.x-L*Math.cos(ang-Math.PI/6),B.y-L*Math.sin(ang-Math.PI/6));
Â  Â  ctx.lineTo(B.x-L*Math.cos(ang+Math.PI/6),B.y-L*Math.sin(ang+Math.PI/6));
Â  Â  ctx.closePath(); ctx.fillStyle=color; ctx.fill();
Â  }
Â  
Â  function render(){
Â  Â  try{
Â  Â  Â  const fenPieces = (frames[idx]||game.fen()).split(' ')[0];
Â  Â  Â  drawBoard(fenPieces);
Â  Â  Â  statusMsg(`PosiciÃ³n ${idx}/${frames.length-1}`);
Â  Â  Â  if (selSquare) {
Â  Â  Â  Â  // Pre-calcular movimientos si hay una casilla seleccionada
Â  Â  Â  Â  possibleMoves = game.moves({square: selSquare, verbose: true});
Â  Â  Â  Â  drawBoard(fenPieces); // Redibujar para mostrar los movimientos
Â  Â  Â  } else {
Â  Â  Â  Â  possibleMoves = [];
Â  Â  Â  }
Â  Â  }catch(e){
Â  Â  Â  statusMsg('Error al dibujar: '+e.message);
Â  Â  Â  console.error(e);
Â  Â  }
Â  }

Â  // ===== Movimiento + promociÃ³n
Â  function needsPromo(from,to){
Â  Â  const p=game.get(from); 
Â  Â  if(!p || p.type !== 'p') return false;
Â  Â  return (p.color === 'w' && to[1] === '8') || (p.color === 'b' && to[1] === '1');
Â  }

Â  function openPromo(cb){
Â  Â  promo.style.display='flex';
Â  Â  const handler=e=>{
Â  Â  Â  const p=e.target?.dataset?.p; 
Â  Â  Â  if(!p) return;
Â  Â  Â  promo.style.display='none'; 
Â  Â  Â  promo.removeEventListener('click',handler); 
Â  Â  Â  cb(p);
Â  Â  };
Â  Â  promo.addEventListener('click',handler);
Â  }

Â  function tryMove(from,to,p){
Â  Â  // Usar game.in_checkmate() y game.in_draw() para mensajes de fin de juego
Â  Â  const mv=game.move({from,to,promotion:p||'q'});
Â  Â  if(!mv){ 
Â  Â  Â  statusMsg(modeSel.value==='kids'?'Â¡Esa no vale! ğŸš«':'Movimiento ilegal'); 
Â  Â  Â  render(); 
Â  Â  Â  return; 
Â  Â  }
Â  Â  lastMove={from:mv.from,to:mv.to}; 
Â  Â  bestArrow=null;
Â  Â  frames.push(game.fen()); 
Â  Â  idx=frames.length-1; 
Â  Â  render(); 
Â  Â  updateMoves();
Â  Â  updateGameStatus(); // Nuevo: para ver si hay mate/tablas
Â  Â  if(auto.checked) scheduleAnalysis();
Â  }

Â  function finishMove(from,to){ 
Â  Â  selSquare = null; // Limpiar selecciÃ³n despuÃ©s de intentar un movimiento
Â  Â  if(needsPromo(from,to)){ 
Â  Â  Â  openPromo(x=>tryMove(from,to,x)); 
Â  Â  } else {
Â  Â  Â  tryMove(from,to); 
Â  Â  }
Â  }

Â  // ===== Manejadores de InteracciÃ³n (Event Listeners)
Â  const mouseUpHandler = e => { 
Â  Â  if(!drag) return; 
Â  Â  const q = getSquareFromEvent(e); 
Â  Â  finishMove(drag.from, rc2alg(q.r, q.c)); 
Â  Â  drag = null; 
Â  };
Â  
Â  const mouseMoveHandler = e => { 
Â  Â  if(!drag) return; 
Â  Â  const q = getSquareFromEvent(e); 
Â  Â  drag.x = q.x; 
Â  Â  drag.y = q.y; 
Â  Â  render(); 
Â  };

Â  // Unificar lÃ³gica de click y drag
Â  canvas.addEventListener('mousedown', e=>{
Â  Â  const q=getSquareFromEvent(e), sq=rc2alg(q.r,q.c), piece=game.get(sq);
Â  Â  if(piece && piece.color === game.turn()){ // Solo la pieza del turno actual
Â  Â  Â  selSquare=sq; 
Â  Â  Â  drag={from:sq, piece:(piece.color==='w'?piece.type.toUpperCase():piece.type), x:q.x,y:q.y}; 
Â  Â  Â  render(); 
Â  Â  } else {
Â  Â  Â  selSquare=null; 
Â  Â  Â  render(); // Limpiar el resaltado si no es una pieza vÃ¡lida
Â  Â  }
Â  });
Â  canvas.addEventListener('mousemove', mouseMoveHandler);
Â  canvas.addEventListener('mouseup', mouseUpHandler);
Â  canvas.addEventListener('mouseleave', ()=>{ if(drag){ drag=null; render(); }});
Â  
Â  // Manejo de TÃ¡ctil (simplificado con listeners de Mouse)
Â  canvas.addEventListener('touchstart', e=>{ 
Â  Â  e.preventDefault(); 
Â  Â  canvas.dispatchEvent(new MouseEvent('mousedown',{clientX:e.touches[0].clientX, clientY:e.touches[0].clientY}));
Â  }, {passive:false});
Â  canvas.addEventListener('touchmove', e=>{ 
Â  Â  e.preventDefault(); 
Â  Â  canvas.dispatchEvent(new MouseEvent('mousemove',{clientX:e.touches[0].clientX, clientY:e.touches[0].clientY}));
Â  }, {passive:false});
Â  // touchend no necesita recrear mouseup con coordenadas, mouseup es suficiente.
Â  
Â  // LÃ³gica Click-Click (para modo no-drag)
Â  canvas.addEventListener('click', e=>{
Â  Â  if(drag) return; // Si fue un drag, evitamos el click
Â  Â  const q=getSquareFromEvent(e), sq=rc2alg(q.r,q.c);
Â  Â  
Â  Â  if(selSquare && selSquare !== sq){ 
Â  Â  Â  finishMove(selSquare, sq); 
Â  Â  } else { 
Â  Â  Â  const piece=game.get(sq); 
Â  Â  Â  // Si no hay pieza o no es tu turno, limpia la selecciÃ³n. Si sÃ­, selecciona.
Â  Â  Â  if (piece && piece.color === game.turn()) {
Â  Â  Â  Â  selSquare = sq;
Â  Â  Â  Â  render();
Â  Â  Â  } else {
Â  Â  Â  Â  selSquare = null;
Â  Â  Â  Â  render();
Â  Â  Â  }
Â  Â  }
Â  });
Â  
Â  // ===== ReproducciÃ³n
Â  function rebuildLast(k){
Â  Â  if(k<=0) return null;
Â  Â  const san=game.history(); const g=new Chess(); let prev=null;
Â  Â  for(let i=0;i<k;i++){ prev=g.move(san[i]); }
Â  Â  return prev ? {from:prev.from,to:prev.to} : null;
Â  }

Â  function goToFrame(newIdx, fromHistory=true){
Â  Â  idx = Math.max(0, Math.min(frames.length - 1, newIdx));
Â  Â  game.load(frames[idx]);
Â  Â  lastMove = rebuildLast(idx);
Â  Â  bestArrow = null; // Limpiar la flecha de anÃ¡lisis al moverse
Â  Â  render();
Â  Â  updateMovesDisplay(idx); // Resaltar el movimiento actual
Â  Â  updateGameStatus();
Â  Â  if(auto.checked && fromHistory) scheduleAnalysis();
Â  }

Â  prevBtn.onclick = () => { goToFrame(idx - 1); };
Â  nextBtn.onclick = () => { goToFrame(idx + 1); };
Â  resetBtn.onclick = () => { goToFrame(0); };
Â  
Â  playBtn.onclick = () => {
Â  Â  if(playing){ 
Â  Â  Â  clearInterval(timer); 
Â  Â  Â  playing=false; 
Â  Â  Â  playBtn.textContent='â–¶ Play'; 
Â  Â  Â  return; 
Â  Â  }
Â  Â  
Â  Â  playing=true; 
Â  Â  playBtn.textContent='â¸ Pausa';
Â  Â  const ms=Math.max(100,+document.getElementById('speed').value||800);
Â  Â  
Â  Â  timer=setInterval(()=>{
Â  Â  Â  if(idx < frames.length - 1){ 
Â  Â  Â  Â  goToFrame(idx + 1, false); // No auto-analizar en cada paso de la animaciÃ³n
Â  Â  Â  } else {
Â  Â  Â  Â  clearInterval(timer); 
Â  Â  Â  Â  playing=false; 
Â  Â  Â  Â  playBtn.textContent='â–¶ Play'; 
Â  Â  Â  Â  if(auto.checked) scheduleAnalysis(); // Analizar al final
Â  Â  Â  }
Â  Â  }, ms);
Â  };
Â  
Â  // ===== PGN y GestiÃ³n de Partidas (Refactorizado)
Â  loadTextBtn.onclick=()=>importPGNCollection(pgnText.value);
Â  file.onchange=async()=>{ 
Â  Â  const f=file.files?.[0]; 
Â  Â  if(!f) return; 
Â  Â  try {
Â  Â  Â  importPGNCollection(await f.text());
Â  Â  } catch (e) {
Â  Â  Â  statusMsg('Error al leer el archivo: '+e.message);
Â  Â  }
Â  };

Â  // DnD al tablero (mejorado con Async/Await y manejo de errores)
Â  ['dragenter','dragover'].forEach(ev=>{
Â  Â  canvas.addEventListener(ev, e=>{ 
Â  Â  Â  e.preventDefault(); 
Â  Â  Â  canvas.style.outline='3px dashed #69a24a'; 
Â  Â  });
Â  });
Â  ['dragleave','drop'].forEach(ev=>{
Â  Â  canvas.addEventListener(ev, e=>{ 
Â  Â  Â  e.preventDefault(); 
Â  Â  Â  canvas.style.outline='none'; 
Â  Â  });
Â  });
Â  canvas.addEventListener('drop', async (e)=>{
Â  Â  const f=e.dataTransfer.files?.[0]; 
Â  Â  if(!f) return;
Â  Â  if(!/\.pgn|\.txt$/i.test(f.name)){ 
Â  Â  Â  alert('Arrastra un archivo .pgn o .txt'); 
Â  Â  Â  return; 
Â  Â  }
Â  Â  try {
Â  Â  Â  importPGNCollection(await f.text());
Â  Â  } catch (e) {
Â  Â  Â  statusMsg('Error al leer el archivo arrastrado: '+e.message);
Â  Â  }
Â  });

Â  function cleanPGN(txt){
Â  Â  return (txt||'')
Â  Â  Â .replace(/^\uFEFF/,'').replace(/\r\n?/g,'\n')
Â  Â  Â .replace(/\$\d+/g,'') // Eliminar sÃ­mbolos (NAGs)
Â  Â  Â .replace(/\{[^}]*\}/g,'') // Eliminar comentarios
Â  Â  Â .replace(/\([^()]*\)/g,'') // Eliminar variaciones (recursivas, pero simplificadas)
Â  Â  Â .replace(/\n{3,}/g,'\n\n').trim();
Â  }
Â  
Â  function splitGames(raw){
Â  Â  const txt=cleanPGN(raw); 
Â  Â  const games = [];
Â  Â  let pgn = '';
Â  Â  // Buscar la secuencia de tags [Event...]. El regex ahora es mÃ¡s simple
Â  Â  const re = /(\[Event\s*"[^"]*"\][\s\S]*?\n\n.*?(?:1-0|0-1|1\/2-1\/2|\*)\s*$)/gm; 
Â  Â  let m;

Â  Â  // Alternativa mÃ¡s robusta:
Â  Â  const lines = txt.split('\n');
Â  Â  let currentPgn = '';
Â  Â  for(const line of lines) {
Â  Â  Â  if (line.startsWith('[')) {
Â  Â  Â  Â  if(line.startsWith('[Event')) {
Â  Â  Â  Â  Â  if(currentPgn.trim()) games.push(currentPgn.trim());
Â  Â  Â  Â  Â  currentPgn = line + '\n';
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  currentPgn += line + '\n';
Â  Â  Â  Â  }
Â  Â  Â  } else if (line.trim()) {
Â  Â  Â  Â  currentPgn += line + '\n';
Â  Â  Â  }
Â  Â  }
Â  Â  if(currentPgn.trim()) games.push(currentPgn.trim());

Â  Â  return games.filter(g => g.includes('[Event')); // Solo PGNs que parecen vÃ¡lidos
Â  }

Â  function gameTitle(pgn){
Â  Â  const tags = ['Event', 'White', 'Black', 'Date', 'Result'];
Â  Â  const info = {};
Â  Â  tags.forEach(tag => {
Â  Â  Â  info[tag] = (pgn.match(new RegExp(`\\[${tag}\\s*"([^"]*)"\\]`)) || [])[1] || `(${tag})`;
Â  Â  });
Â  Â  return `${info.Event} â€” ${info.White} vs ${info.Black} (${info.Date}, ${info.Result})`;
Â  }

Â  let loadedGames = []; // Almacenar las partidas importadas
Â  function importPGNCollection(raw){
Â  Â  try{
Â  Â  Â  loadedGames = splitGames(raw); 
Â  Â  Â  if(!loadedGames.length){ 
Â  Â  Â  Â  alert('No se encontraron partidas vÃ¡lidas en el archivo.'); 
Â  Â  Â  Â  return; 
Â  Â  Â  }
Â  Â  Â  
Â  Â  Â  gameSelect.innerHTML = '';
Â  Â  Â  loadedGames.forEach((g,i)=>{ 
Â  Â  Â  Â  const o=document.createElement('option'); 
Â  Â  Â  Â  o.value=i; 
Â  Â  Â  Â  o.textContent=gameTitle(g); 
Â  Â  Â  Â  gameSelect.appendChild(o); 
Â  Â  Â  });
Â  Â  Â  
Â  Â  Â  document.getElementById('gameCount').textContent=loadedGames.length > 1 ? `(${loadedGames.length})` : '';
Â  Â  Â  document.getElementById('gamePicker').style.display=loadedGames.length > 1 ? 'flex' : 'none';
Â  Â  Â  
Â  Â  Â  gameSelect.onchange = () => loadPGN(loadedGames[+gameSelect.value], true);
Â  Â  Â  loadPGN(loadedGames[0], true);

Â  Â  }catch(e){
Â  Â  Â  statusMsg('Error importando PGN: '+e.message);
Â  Â  Â  console.error(e);
Â  Â  }
Â  }
Â  
Â  function loadPGN(pgn, reset=true){
Â  Â  game.reset(); // Asegurar un estado limpio antes de cargar
Â  Â  const ok=game.load_pgn(pgn,{sloppy:true}); 
Â  Â  if(!ok){ 
Â  Â  Â  alert('PGN invÃ¡lido o formato incorrecto.'); 
Â  Â  Â  return false; 
Â  Â  }
Â  Â  
Â  Â  // Regenerar frames
Â  Â  const san = game.history(); 
Â  Â  game.reset(); 
Â  Â  frames=[game.fen()]; 
Â  Â  let mv=null;
Â  Â  
Â  Â  for(const m of san){ 
Â  Â  Â  mv=game.move(m); 
Â  Â  Â  frames.push(game.fen()); 
Â  Â  }
Â  Â  
Â  Â  idx=frames.length-1; 
Â  Â  lastMove=mv?{from:mv.from,to:mv.to}:null; 
Â  Â  bestArrow=null;
Â  Â  
Â  Â  render(); 
Â  Â  updateMovesDisplay(idx); 
Â  Â  updateGameStatus();
Â  Â  if(auto.checked) scheduleAnalysis();
Â  Â  
Â  Â  if(reset) statusMsg('Partida cargada.');
Â  Â  return true;
Â  }

Â  function updateGameStatus() {
Â  Â  const result = game.header().Result || '*';
Â  Â  if (game.in_checkmate()) {
Â  Â  Â  statusMsg(modeSel.value === 'kids' ? 'Â¡Jaque Mate! Â¡Fin del juego! ğŸ†' : 'Jaque Mate. Partida terminada.');
Â  Â  } else if (game.in_draw()) {
Â  Â  Â  statusMsg('Â¡Tablas! Empate. ğŸ¤');
Â  Â  } else if (game.in_check()) {
Â  Â  Â  statusMsg(modeSel.value === 'kids' ? 'Â¡Jaque! Defiende tu Rey. ğŸ‘‘' : 'Jaque.');
Â  Â  } else {
Â  Â  Â  // Restaura el mensaje normal
Â  Â  Â  statusMsg(modeSel.value === 'kids' ? 'Â¡Listo para jugar! ğŸŒŸ Arrastra o toca para mover.' : 'Tablero listo. Arrastra o haz click-click para mover.');
Â  Â  }
Â  }

Â  function updateMovesDisplay(currentIdx){
Â  Â  const san=game.history(); 
Â  Â  movesBox.innerHTML='';
Â  Â  
Â  Â  // Crear una estructura con los movimientos por turno
Â  Â  const turns = [];
Â  Â  for (let i = 0; i < san.length; i++) {
Â  Â  Â  if (i % 2 === 0) {
Â  Â  Â  Â  turns.push({
Â  Â  Â  Â  Â  turnNum: Math.floor(i / 2) + 1,
Â  Â  Â  Â  Â  wMove: san[i],
Â  Â  Â  Â  Â  bMove: san[i+1] || null
Â  Â  Â  Â  });
Â  Â  Â  }
Â  Â  }

Â  Â  turns.forEach((t, i) => {
Â  Â  Â  const turnSpan = document.createElement('span');
Â  Â  Â  turnSpan.className = 'note';
Â  Â  Â  turnSpan.textContent = t.turnNum + '. ';
Â  Â  Â  movesBox.appendChild(turnSpan);

Â  Â  Â  // Movimiento de Blancas
Â  Â  Â  let spW = createMoveSpan(t.wMove, i * 2 + 1, currentIdx);
Â  Â  Â  movesBox.appendChild(spW);
Â  Â  Â  movesBox.appendChild(document.createTextNode(' '));

Â  Â  Â  // Movimiento de Negras
Â  Â  Â  if (t.bMove) {
Â  Â  Â  Â  let spB = createMoveSpan(t.bMove, i * 2 + 2, currentIdx);
Â  Â  Â  Â  movesBox.appendChild(spB);
Â  Â  Â  Â  movesBox.appendChild(document.createTextNode(' '));
Â  Â  Â  }
Â  Â  });
Â  Â  
Â  Â  gameInfoEl.textContent=`Movidas: ${san.length} | Resultado: ${game.header().Result || '*'}`;
Â  }

Â  function createMoveSpan(move, moveIdx, currentIdx) {
Â  Â  const sp = document.createElement('span');
Â  Â  sp.textContent = move;
Â  Â  sp.style.cursor = 'pointer';
Â  Â  if (moveIdx === currentIdx) {
Â  Â  Â  sp.style.backgroundColor = '#2f7d4e'; // Resaltar movimiento actual
Â  Â  Â  sp.style.borderRadius = '4px';
Â  Â  Â  sp.style.padding = '2px 4px';
Â  Â  Â  sp.style.margin = '-2px -4px'; // Ajuste visual
Â  Â  }
Â  Â  sp.onclick = () => { goToFrame(moveIdx); };
Â  Â  return sp;
Â  }
Â  
Â  document.getElementById('copyFenBtn').onclick=async()=>{
Â  Â  const fen=frames[idx]||game.fen(); 
Â  Â  try {
Â  Â  Â  await navigator.clipboard.writeText(fen);
Â  Â  Â  statusMsg(modeSel.value==='kids'?'Â¡FEN copiado! ğŸ“‹':'FEN copiado.');
Â  Â  } catch(e) {
Â  Â  Â  statusMsg('Error al copiar FEN. Intenta manualmente.');
Â  Â  }
Â  };

Â  // ===== Motor (Stockfish)
Â  let engine=null, lastDepth=0, lastUi=0;
Â  const UI_MS=400;
Â  const MIRRORS=[
Â  Â  'https://cdnjs.cloudflare.com/ajax/libs/stockfish.js/11.0.0/stockfish.min.js', // Actualizado a v11.0.0 (mÃ¡s reciente en CDN)
Â  Â  'https://cdnjs.cloudflare.com/ajax/libs/stockfish.js/9.0.0/stockfish.js'
Â  ];
Â  
Â  function ensureEngine(){
Â  Â  if(engine) return engine;
Â  Â  // Se usa un enfoque de "inline" worker para mayor fiabilidad al cargar
Â  Â  const code=`self.onerror=e=>postMessage({type:'sf-error',msg:String(e&&e.message||e)});
try{importScripts('${MIRRORS[0]}');postMessage({type:'sf-ok',src:'CDNJS'});}
catch(e){try{importScripts('${MIRRORS[1]}');postMessage({type:'sf-ok',src:'CDNJS fallback'});}
catch(err){postMessage({type:'sf-error',msg:'No se pudo cargar Stockfish.'});}}`;
Â  Â  engine=new Worker(URL.createObjectURL(new Blob([code],{type:'application/javascript'})));
Â  Â  engine.onmessage=onEngineMessage; 
Â  Â  return engine;
Â  }
Â  
Â  function uciToNice(uci){
Â  Â  if(!uci||uci==='â€”') return 'â€”';
Â  Â  // Crear una instancia temporal de chess.js para el SAN.
Â  Â  // Esto es mÃ¡s robusto que construir la notaciÃ³n manualmente.
Â  Â  const gTemp = new Chess(frames[idx] || game.fen());
Â  Â  try {
Â  Â  Â  const move = gTemp.move(uci, {sloppy: true});
Â  Â  Â  return move ? move.san : uci;
Â  Â  } catch (e) {
Â  Â  Â  return uci; // Fallback si no es un movimiento UCI vÃ¡lido
Â  Â  }
Â  }

Â  function cpToEval(cp, turn) {
Â  Â  const sign = turn === 'w' ? 1 : -1;
Â  Â  const value = cp * sign / 100;
Â  Â  return value.toFixed(2);
Â  }
Â  
Â  function humanEval(evalStr){
Â  Â  if(modeSel.value!=='kids') return evalStr;
Â  Â  
Â  Â  if(evalStr==='â€”') return 'Pensandoâ€¦ ğŸ¤”';
Â  Â  if(evalStr.startsWith('#')) return 'Â¡Mate a la vista! ğŸ';
Â  Â  
Â  Â  const n=Number(evalStr);
Â  Â  if(isNaN(n)) return 'Pensandoâ€¦ ğŸ¤”';

Â  Â  if(n>=2.0) return 'Â¡Ventaja aplastante! ğŸ’ª';
Â  Â  if(n>=1.0) return 'Â¡Ventaja grande! ğŸ˜„';
Â  Â  if(n>=0.4) return 'Un poco mejor ğŸ™‚';
Â  Â  if(n>-0.4) return 'Igualado ğŸ˜';
Â  Â  if(n>-1.0) return 'Cuidadito ğŸ™';
Â  Â  if(n>-2.0) return 'PosiciÃ³n difÃ­cil ğŸ˜Ÿ';
Â  Â  return 'Â¡Peligro! ğŸš¨';
Â  }

Â  function showEval(ev,depth,best,srcText=''){
Â  Â  const box=document.getElementById('evalBox');
Â  Â  box.innerHTML = `Eval: <b>${humanEval(ev)}</b> | Profundidad: ${depth} | Mejor jugada: ${best} `;
Â  Â  const src=document.createElement('span'); 
Â  Â  src.id='engineSrc'; src.className='note'; 
Â  Â  src.textContent = srcText;
Â  Â  box.appendChild(src);
Â  }
Â  
Â  function showPV(pv){
Â  Â  const toks=pv.trim().split(/\s+/).slice(0, 10); // Limitar a 10 jugadas para brevedad
Â  Â  document.getElementById('pvBox').textContent=toks.map(uciToNice).join(' ')||'â€”';
Â  }

Â  function onEngineMessage(e){
Â  Â  const d=e.data;
Â  Â  
Â  Â  if(d?.type==='sf-ok'){ 
Â  Â  Â  showEval('â€”','â€”','â€”', ` (motor: ${d.src})`);
Â  Â  Â  return; 
Â  Â  }
Â  Â  if(d?.type==='sf-error'){ 
Â  Â  Â  showEval('â€”','â€”','â€”',' (motor: error)'); 
Â  Â  Â  return; 
Â  Â  }
Â  Â  
Â  Â  const line=(typeof d==='string')?d:(d?.data||''); 
Â  Â  if(!line||!line.startsWith('info ')) return;

Â  Â  const depthMatch = line.match(/\bdepth\s+(\d+)/);
Â  Â  const depth = depthMatch ? +depthMatch[1] : lastDepth;
Â  Â  
Â  Â  // Evitar actualizar el UI con informaciÃ³n mÃ¡s antigua
Â  Â  if(depth < lastDepth) return;
Â  Â  
Â  Â  const now=performance.now(); 
Â  Â  if(now - lastUi < UI_MS && depth === lastDepth) return;
Â  Â  
Â  Â  lastDepth = depth; 
Â  Â  lastUi = now;

Â  Â  const cpMatch = line.match(/\bcp\s+(-?\d+)/);
Â  Â  const mateMatch = line.match(/\bmate\s+(-?\d+)/);
Â  Â  const pvMatch = line.match(/\bpv\s+(.+)/);
Â  Â  
Â  Â  const cp = cpMatch ? cpMatch[1] : null;
Â  Â  const mate = mateMatch ? mateMatch[1] : null;
Â  Â  const pv = pvMatch ? pvMatch[1] : '';
Â  Â  const best = pv.split(' ')[0] || 'â€”';
Â  Â  
Â  Â  const currentFen = frames[idx] || game.fen();
Â  Â  const turn = currentFen.split(' ')[1];
Â  Â  
Â  Â  const evalStr = mate ? ('#'+mate) : (cp ? cpToEval(Number(cp), turn) : 'â€”');
Â  Â  
Â  Â  showEval(evalStr, depth, uciToNice(best), document.getElementById('engineSrc')?.textContent || '');
Â  Â  showPV(pv);

Â  Â  const dMax=Math.max(6,Math.min(30,+maxDepthInput.value||18));
Â  Â  depthBar.style.width=`${Math.min(100,Math.round(depth/dMax*100))}%`;

Â  Â  if(best.length>=4){ 
Â  Â  Â  // Solo mostrar la flecha de la mejor jugada principal (MultiPV 1)
Â  Â  Â  bestArrow={from:best.slice(0,2),to:best.slice(2,4)}; 
Â  Â  Â  render(); 
Â  Â  }
Â  }
Â  
Â  let deb = null;
Â  function scheduleAnalysis(){ 
Â  Â  if(playing) return; // No analizar durante la reproducciÃ³n
Â  Â  clearTimeout(deb); 
Â  Â  deb=setTimeout(runAnalysis,500); 
Â  }

Â  function runAnalysis(){
Â  Â  ensureEngine(); 
Â  Â  if(!engine) return;
Â  Â  
Â  Â  lastDepth=0; 
Â  Â  lastUi=0;
Â  Â  
Â  Â  const depth=Math.max(6,Math.min(30,+maxDepthInput.value||18));
Â  Â  const multi=Math.max(1,Math.min(3,+multipvInput.value||1));
Â  Â  const fen=frames[idx]||game.fen();
Â  Â  
Â  Â  showEval('â€¦','â€”','â€”', document.getElementById('engineSrc')?.textContent || ''); 
Â  Â  showPV('Pensandoâ€¦');
Â  Â  
Â  Â  engine.postMessage('stop');
Â  Â  engine.postMessage('uci');
Â  Â  engine.postMessage('setoption name MultiPV value '+multi);
Â  Â  engine.postMessage('isready');
Â  Â  engine.postMessage('ucinewgame');
Â  Â  engine.postMessage('position fen '+fen);
Â  Â  engine.postMessage('go depth '+depth);
Â  }
Â  
Â  goBtn.onclick=runAnalysis;
Â  stopBtn.onclick=()=>{ 
Â  Â  if(engine) engine.postMessage('stop'); 
Â  Â  statusMsg('AnÃ¡lisis detenido.');
Â  };
Â  
Â  // Ejecutar anÃ¡lisis automÃ¡ticamente si la profundidad o multiPV cambian
Â  maxDepthInput.onchange = () => { if(auto.checked) scheduleAnalysis(); };
Â  multipvInput.onchange = () => { if(auto.checked) scheduleAnalysis(); };

Â  // ===== Init
Â  window.addEventListener('load', ()=>{
Â  Â  frames=[game.fen()]; idx=0;
Â  Â  resizeBoard();
Â  Â  updateMovesDisplay(0);
Â  Â  updateGameStatus();
Â  Â  // Cargar motor en el inicio, sin analizar, solo para el mensaje de OK
Â  Â  ensureEngine(); 
Â  });

})(); // IIFE
</script>
</body>
</html>
