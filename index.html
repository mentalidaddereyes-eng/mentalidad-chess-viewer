<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>Visor PGN ‚Äî Tablero Interactivo + An√°lisis</title>

<!-- Reglas y parsing de ajedrez -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.12.0/chess.min.js"></script>

<style>
  :root {
    /* Colores base */
    --bg: #0c1422;
    --panel: #0f1b2e;
    --borde: #232a36;
    --txt: #e6edf3;
    --muted: #9fb0c3;
    
    /* Colores del tablero */
    --sq-light: #f0f8f0;
    --sq-dark: #769656;
    --sq-light-child: #fff8dc;
    --sq-dark-child: #deb887;
    
    /* Botones */
    --btn: #24324a;
    --btnbd: #3b4a63;
    --btnh: #2b3f5e;
    --ok: #22c55e;
    --primary: #2f7d4e;
    --primary-hover: #256f43;
    
    /* Modo ni√±os */
    --child-bg: #1a2a3a;
    --child-panel: #243447;
    --child-txt: #f0f8ff;
  }

  /* Reset y base */
  * {
    box-sizing: border-box;
  }

  body {
    margin: 0;
    background: var(--bg);
    color: var(--txt);
    font: 16px/1.4 Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    min-height: 100vh;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    overflow-x: hidden;
  }

  /* Modo ni√±os */
  body.child-mode {
    --bg: var(--child-bg);
    --panel: var(--child-panel);
    --txt: var(--child-txt);
    --sq-light: var(--sq-light-child);
    --sq-dark: var(--sq-dark-child);
  }

  /* Layout principal */
  h1 {
    max-width: 1200px;
    margin: 12px auto 8px;
    padding: 0 16px;
    font-size: clamp(20px, 4vw, 28px);
    text-align: center;
    font-weight: 600;
  }

  .wrap {
    max-width: 1200px;
    margin: 0 auto;
    padding: 8px 12px;
  }

  .grid {
    display: grid;
    grid-template-columns: 1fr minmax(300px, 400px);
    gap: 16px;
  }

  /* Responsive */
  @media (max-width: 1024px) {
    .grid {
      grid-template-columns: 1fr;
      gap: 12px;
    }
    .wrap {
      padding: 8px 10px;
    }
  }

  @media (max-width: 768px) {
    .wrap {
      padding: 6px 8px;
    }
    h1 {
      margin: 8px auto 6px;
      padding: 0 12px;
    }
  }

  @media (max-width: 480px) {
    .wrap {
      padding: 4px 6px;
    }
    h1 {
      padding: 0 8px;
    }
  }

  /* Paneles */
  .panel {
    background: var(--panel);
    border: 1px solid var(--borde);
    border-radius: 12px;
    padding: 16px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
  }

  /* Canvas optimizado - FIX PRINCIPAL */
  #canvasBox {
    width: 100%;
    max-width: min(720px, 90vw);
    margin: auto;
    position: relative;
    display: flex;
    justify-content: center;
    align-items: center;
  }

  canvas {
    width: 100%;
    max-width: 720px;
    height: auto;
    display: block;
    border: 2px solid var(--borde);
    border-radius: 12px;
    background: transparent;
    aspect-ratio: 1;
    touch-action: none;
    /* Renderizado de alta calidad */
    image-rendering: -webkit-optimize-contrast;
    image-rendering: crisp-edges;
    image-rendering: pixelated;
    /* Mejorar nitidez */
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    text-rendering: optimizeLegibility;
    /* Prevenir expansi√≥n indefinida */
    min-width: 0;
    min-height: 0;
    object-fit: contain;
    /* Sombra sutil para profundidad */
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
  }

  @media (max-width: 768px) {
    #canvasBox {
      max-width: min(600px, 95vw);
    }
  }

  @media (max-width: 480px) {
    #canvasBox {
      max-width: min(400px, 98vw);
    }
  }

  /* Estado */
  .status {
    margin-top: 12px;
    color: var(--ok);
    font-size: 14px;
    text-align: center;
    font-weight: 500;
  }

  /* Controles */
  .controls {
    display: flex;
    gap: 8px;
    flex-wrap: wrap;
    align-items: center;
    justify-content: center;
    margin-top: 12px;
  }

  @media (max-width: 768px) {
    .controls {
      gap: 6px;
      justify-content: flex-start;
    }
  }

  /* Botones mejorados */
  button {
    background: var(--btn);
    border: 1px solid var(--btnbd);
    color: var(--txt);
    border-radius: 8px;
    padding: 12px 16px;
    cursor: pointer;
    font-size: 14px;
    font-weight: 500;
    transition: all 0.2s ease;
    min-height: 44px;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 6px;
    user-select: none;
    -webkit-tap-highlight-color: transparent;
    position: relative;
    overflow: hidden;
  }

  button:hover {
    background: var(--btnh);
    transform: translateY(-1px);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
  }

  button:active {
    transform: translateY(0);
    box-shadow: 0 1px 4px rgba(0, 0, 0, 0.2);
  }

  button:disabled {
    opacity: 0.6;
    cursor: not-allowed;
    transform: none;
  }

  @media (max-width: 480px) {
    button {
      padding: 10px 12px;
      font-size: 13px;
      min-height: 40px;
    }
  }

  .primary {
    background: var(--primary);
    border-color: var(--primary);
  }

  .primary:hover {
    background: var(--primary-hover);
  }

  .ghost {
    background: transparent;
    border-color: var(--borde);
  }

  /* Chips y controles */
  .chip {
    padding: 10px 14px;
    border-radius: 8px;
    border: 1px solid var(--borde);
    background: rgba(11, 22, 39, 0.5);
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 14px;
  }

  @media (max-width: 480px) {
    .chip {
      padding: 8px 10px;
      font-size: 13px;
    }
  }

  /* Inputs mejorados */
  input, select, textarea {
    font: inherit;
    background: rgba(11, 22, 39, 0.8);
    border: 1px solid var(--borde);
    border-radius: 6px;
    padding: 10px 12px;
    color: var(--txt);
    transition: all 0.2s ease;
  }

  input:focus, select:focus, textarea:focus {
    outline: none;
    border-color: var(--ok);
    box-shadow: 0 0 0 2px rgba(34, 197, 94, 0.2);
  }

  input[type="number"] {
    width: 80px;
    text-align: center;
  }

  @media (max-width: 480px) {
    input[type="number"] {
      width: 70px;
      padding: 8px;
    }
  }

  textarea {
    width: 100%;
    min-height: 120px;
    resize: vertical;
    font-size: 14px;
    line-height: 1.5;
  }

  @media (max-width: 480px) {
    textarea {
      min-height: 100px;
      font-size: 13px;
    }
  }

  /* Cajas de informaci√≥n */
  .box {
    background: rgba(11, 22, 39, 0.6);
    border: 1px solid var(--borde);
    border-radius: 8px;
    padding: 14px;
    min-height: 60px;
    font-size: 14px;
  }

  @media (max-width: 480px) {
    .box {
      padding: 12px;
      min-height: 50px;
      font-size: 13px;
    }
  }

  .mono {
    font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
    white-space: pre-wrap;
    font-size: 13px;
    line-height: 1.5;
  }

  @media (max-width: 480px) {
    .mono {
      font-size: 12px;
    }
  }

  .note {
    color: var(--muted);
    font-size: 14px;
    text-align: center;
  }

  @media (max-width: 480px) {
    .note {
      font-size: 13px;
    }
  }

  /* Barra de progreso */
  .bar {
    height: 8px;
    border-radius: 999px;
    background: rgba(18, 32, 52, 0.8);
    overflow: hidden;
    flex: 1;
    min-width: 100px;
  }

  .bar > i {
    display: block;
    height: 100%;
    background: linear-gradient(90deg, #2dd4bf, #22c55e);
    width: 0%;
    transition: width 0.3s ease;
  }

  /* File input disfrazado */
  #file {
    display: none;
  }

  label[for="file"] {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    cursor: pointer;
    transition: all 0.2s ease;
  }

  label[for="file"]:hover {
    transform: translateY(-1px);
  }

  label[for="file"]::before {
    content: "üìÇ";
    font-size: 16px;
  }

  /* Selector de partida */
  #gamePicker {
    display: none;
    margin-top: 8px;
    flex-direction: column;
    align-items: stretch;
  }

  @media (max-width: 768px) {
    #gamePicker {
      margin-top: 6px;
    }
  }

  #gameSelect {
    width: 100%;
    margin-top: 6px;
  }

  /* Modal de promoci√≥n mejorado */
  #promo {
    position: fixed;
    inset: 0;
    display: none;
    align-items: center;
    justify-content: center;
    background: rgba(0, 0, 0, 0.8);
    z-index: 1000;
    backdrop-filter: blur(8px);
  }

  #promo .card {
    background: var(--panel);
    border: 1px solid var(--borde);
    padding: 24px;
    border-radius: 16px;
    max-width: 320px;
    width: 90%;
    text-align: center;
    box-shadow: 0 12px 40px rgba(0, 0, 0, 0.6);
  }

  @media (max-width: 480px) {
    #promo .card {
      padding: 20px;
      max-width: 300px;
    }
  }

  #promo .card h3 {
    margin: 0 0 20px 0;
    font-size: 18px;
    color: var(--txt);
    font-weight: 600;
  }

  @media (max-width: 480px) {
    #promo .card h3 {
      font-size: 16px;
      margin: 0 0 16px 0;
    }
  }

  #promo .choices {
    display: flex;
    gap: 12px;
    justify-content: center;
    flex-wrap: wrap;
  }

  @media (max-width: 480px) {
    #promo .choices {
      gap: 10px;
    }
  }

  #promo button {
    font-size: 32px;
    padding: 16px 20px;
    min-width: 60px;
    min-height: 60px;
    border-radius: 12px;
    background: var(--btn);
    border: 1px solid var(--btnbd);
    color: var(--txt);
    cursor: pointer;
    transition: all 0.2s ease;
  }

  #promo button:hover {
    background: var(--btnh);
    transform: scale(1.05);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
  }

  @media (max-width: 480px) {
    #promo button {
      font-size: 28px;
      padding: 12px 16px;
      min-width: 50px;
      min-height: 50px;
    }
  }

  /* Modo ni√±os espec√≠fico */
  body.child-mode #promo button {
    font-size: 36px;
    background: #4a90e2;
    border-color: #4a90e2;
  }

  body.child-mode #promo button:hover {
    background: #357abd;
  }

  /* Indicadores de modo */
  .mode-indicator {
    position: fixed;
    top: 16px;
    right: 16px;
    padding: 8px 12px;
    background: var(--primary);
    color: white;
    border-radius: 20px;
    font-size: 12px;
    font-weight: 600;
    z-index: 100;
    transition: all 0.3s ease;
  }

  body.child-mode .mode-indicator {
    background: #4a90e2;
  }

  /* Mejoras de accesibilidad */
  @media (prefers-reduced-motion: reduce) {
    * {
      animation-duration: 0.01ms !important;
      animation-iteration-count: 1 !important;
      transition-duration: 0.01ms !important;
    }
  }

  /* Focus visible */
  button:focus-visible,
  input:focus-visible,
  select:focus-visible,
  textarea:focus-visible {
    outline: 2px solid var(--ok);
    outline-offset: 2px;
  }

  /* Estados de carga */
  .loading {
    opacity: 0.7;
    pointer-events: none;
  }

  .loading::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 20px;
    height: 20px;
    margin: -10px 0 0 -10px;
    border: 2px solid var(--ok);
    border-top: 2px solid transparent;
    border-radius: 50%;
    animation: spin 1s linear infinite;
  }

  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }

  /* Prevenir overflow en m√≥viles */
  @media (max-width: 768px) {
    body {
      overflow-x: hidden;
    }
    
    .wrap {
      overflow-x: hidden;
    }
  }
</style>
</head>
<body>
  <h1>Visor PGN ‚Äî Tablero Interactivo + An√°lisis</h1>
  <div id="modeIndicator" class="mode-indicator">Modo Adultos</div>

  <div class="wrap grid">
    <!-- Panel izquierdo - Tablero -->
    <div class="panel">
      <div id="canvasBox">
        <canvas id="board" width="720" height="720" 
                role="img" 
                aria-label="Tablero de ajedrez interactivo">
        </canvas>
      </div>

      <div class="controls">
        <button id="prevBtn" class="ghost" aria-label="Movimiento anterior">‚Üê Anterior</button>
        <button id="playBtn" class="primary" aria-label="Reproducir partida">‚ñ∂ Play</button>
        <button id="nextBtn" class="ghost" aria-label="Siguiente movimiento">Siguiente ‚Üí</button>
        <button id="resetBtn" class="ghost" aria-label="Reiniciar partida">Reiniciar</button>
        <label class="chip" for="speed">
          <span>Velocidad</span>
          <input id="speed" type="number" value="800" min="100" step="50" aria-label="Velocidad de reproducci√≥n">
        </label>
        <label class="chip">
          <input id="auto" type="checkbox" checked aria-label="An√°lisis autom√°tico">
          <span>Auto-analizar</span>
        </label>
        <button id="modeToggle" class="ghost" aria-label="Cambiar modo">üë∂ Modo Ni√±os</button>
      </div>

      <div id="status" class="status" role="status" aria-live="polite">
        OK: tablero listo. Click o arrastra para mover.
      </div>
    </div>

    <!-- Panel derecho - Controles -->
    <div class="panel">
      <div class="controls">
        <label for="file" class="primary" aria-label="Abrir archivo PGN">üìÇ Abrir PGN</label>
        <input id="file" type="file" accept=".pgn,.txt" aria-label="Seleccionar archivo PGN">
        <button id="copyFenBtn" class="ghost" aria-label="Copiar posici√≥n FEN">Copiar FEN</button>
      </div>

      <div id="gamePicker" class="controls">
        <span class="note">Partidas en el archivo:</span>
        <select id="gameSelect" class="chip" aria-label="Seleccionar partida"></select>
        <span id="gameCount" class="note"></span>
      </div>

      <div class="note" style="margin: 12px 0 8px">
        O pega PGN aqu√≠ (opcional) y pulsa "Importar":
      </div>
      <textarea id="pgnText" 
                placeholder="(Opcional) Pega tu PGN aqu√≠‚Ä¶"
                aria-label="√Årea de texto para pegar PGN"></textarea>
      
      <div class="controls" style="margin-top: 12px">
        <button id="loadTextBtn" class="primary" aria-label="Importar PGN del texto">Importar</button>
        <span id="gameInfo" class="note">Sin partida cargada.</span>
      </div>

      <div id="movesBox" class="box mono" 
           style="margin-top: 12px; min-height: 60px"
           aria-label="Lista de movimientos">
        Movidas aparecer√°n aqu√≠‚Ä¶
      </div>

      <div class="controls" style="margin-top: 16px">
        <span class="note">An√°lisis Stockfish</span>
        <div class="bar" style="flex: 1">
          <i id="depthBar" style="width: 0%"></i>
        </div>
      </div>

      <div class="controls" style="gap: 12px; margin-top: 12px">
        <label class="chip">
          <span>Profundidad m√°x:</span>
          <input id="maxDepth" type="number" min="6" max="30" value="18" aria-label="Profundidad m√°xima de an√°lisis">
        </label>
        <label class="chip">
          <span>L√≠neas:</span>
          <input id="multipv" type="number" min="1" max="3" value="1" aria-label="N√∫mero de l√≠neas a mostrar">
        </label>
        <button id="goBtn" class="primary" aria-label="Iniciar an√°lisis">Analizar</button>
        <button id="stopBtn" class="ghost" aria-label="Detener an√°lisis">Detener</button>
      </div>

      <div id="evalBox" class="box" style="margin-top: 12px"
           aria-label="Evaluaci√≥n de la posici√≥n">
        Eval: ‚Äî | Profundidad: ‚Äî | Mejor jugada: ‚Äî 
        <span id="engineSrc" class="note"></span>
      </div>
      
      <div id="pvBox" class="box mono" style="margin-top: 12px"
           aria-label="L√≠nea principal de variaci√≥n">
        L√≠neas aparecer√°n aqu√≠‚Ä¶
      </div>
    </div>
  </div>

  <!-- Modal de promoci√≥n -->
  <div id="promo" role="dialog" aria-labelledby="promo-title" aria-modal="true">
    <div class="card">
      <h3 id="promo-title">Elige pieza de promoci√≥n</h3>
      <div class="choices">
        <button data-p="q" aria-label="Promocionar a Dama">‚ôï</button>
        <button data-p="r" aria-label="Promocionar a Torre">‚ôñ</button>
        <button data-p="b" aria-label="Promocionar a Alfil">‚ôó</button>
        <button data-p="n" aria-label="Promocionar a Caballo">‚ôò</button>
      </div>
    </div>
  </div>

<script>
/* ============ CONFIGURACI√ìN Y CONSTANTES ============ */
const CONFIG = {
  CANVAS_SIZE: 720,
  SQUARE_SIZE: 720 / 8,
  PIECE_FONT_SIZE: 0.82,
  SHADOW_BLUR: 0.08,
  STROKE_WIDTH: 0.08,
  ANALYSIS_DELAY: 300,
  TOUCH_VIBRATION: 50,
  MAX_DEPTH_MOBILE: 12,
  MAX_DEPTH_DESKTOP: 18,
  PIECE_HIGHLIGHT_SCALE: 1.05,
  PIECE_GRADIENT_INTENSITY: 0.3
};

const COLORS = {
  light: '#f0f8f0',
  dark: '#769656',
  lightChild: '#fff8dc',
  darkChild: '#deb887',
  pieceWhite: '#ffffff',
  pieceBlack: '#1a1a1a',
  pieceWhiteGradient: '#f8f8f8',
  pieceBlackGradient: '#2d2d2d',
  highlight: 'rgba(255,255,0,0.25)',
  shadow: 'rgba(0,0,0,0.45)',
  shadowLight: 'rgba(255,255,255,0.15)',
  pieceStrokeWhite: 'rgba(0,0,0,0.9)',
  pieceStrokeBlack: 'rgba(255,255,255,0.95)'
};

const PIECE_SYMBOLS = {
  'P': '‚ôô', 'N': '‚ôò', 'B': '‚ôó', 'R': '‚ôñ', 'Q': '‚ôï', 'K': '‚ôî',
  'p': '‚ôü', 'n': '‚ôû', 'b': '‚ôù', 'r': '‚ôú', 'q': '‚ôõ', 'k': '‚ôö'
};

const PROMOTION_PIECES = {
  'q': '‚ôï', 'r': '‚ôñ', 'b': '‚ôó', 'n': '‚ôò'
};

/* ============ ELEMENTOS DOM ============ */
const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d', { 
  alpha: true,
  desynchronized: true,
  colorSpace: 'srgb'
});

// Configurar canvas para alta calidad
function setupCanvasQuality() {
  const devicePixelRatio = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  
  // Establecer el tama√±o real del canvas en memoria
  canvas.width = CONFIG.CANVAS_SIZE * devicePixelRatio;
  canvas.height = CONFIG.CANVAS_SIZE * devicePixelRatio;
  
  // Establecer el tama√±o de visualizaci√≥n del canvas
  canvas.style.width = CONFIG.CANVAS_SIZE + 'px';
  canvas.style.height = CONFIG.CANVAS_SIZE + 'px';
  
  // Escalar el contexto para que coincida con la densidad del dispositivo
  ctx.scale(devicePixelRatio, devicePixelRatio);
  
  // Configurar renderizado de alta calidad
  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = 'high';
  
  // Configurar composici√≥n para mejor renderizado de texto
  ctx.globalCompositeOperation = 'source-over';
}

const modeIndicator = document.getElementById('modeIndicator');

/* ============ ESTADO GLOBAL ============ */
let game = new Chess();
let frames = [game.fen()];
let currentIndex = 0;
let isPlaying = false;
let playTimer = null;
let selectedSquare = null;
let dragState = null;
let isTouch = false;
let touchStartTime = 0;
let isChildMode = false;

/* ============ MOTOR DE AN√ÅLISIS ============ */
let engine = null;
let engineReady = false;
let lastDepth = 0;
let lastBest = '';
let isAnalyzing = false;
let analysisTimer = null;

const ENGINE_SOURCES = [
  './engine/stockfish.js',
  'https://cdnjs.cloudflare.com/ajax/libs/stockfish.js/9.0.0/stockfish.min.js',
  'https://cdnjs.cloudflare.com/ajax/libs/stockfish.js/9.0.0/stockfish.js'
];

/* ============ FUNCIONES DE UTILIDAD ============ */
function getCssVar(name) {
  return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
}

function getCurrentColors() {
  return isChildMode ? 
    { light: COLORS.lightChild, dark: COLORS.darkChild } :
    { light: COLORS.light, dark: COLORS.dark };
}

function log(message, type = 'info') {
  console[type](`[ChessViewer] ${message}`);
}

function setStatus(message) {
  const statusEl = document.getElementById('status');
  if (statusEl) {
    statusEl.textContent = message;
    statusEl.setAttribute('aria-live', 'polite');
  }
}

/* ============ RENDERIZADO DEL TABLERO OPTIMIZADO ============ */
function drawBoard(fenPieces, highlight = null) {
  const colors = getCurrentColors();
  
  // Limpiar canvas completamente
  ctx.clearRect(0, 0, CONFIG.CANVAS_SIZE, CONFIG.CANVAS_SIZE);
  
  // Dibujar casillas
  for (let row = 0; row < 8; row++) {
    for (let col = 0; col < 8; col++) {
      const isLight = (row + col) % 2 === 0;
      ctx.fillStyle = isLight ? colors.light : colors.dark;
      ctx.fillRect(col * CONFIG.SQUARE_SIZE, row * CONFIG.SQUARE_SIZE, CONFIG.SQUARE_SIZE, CONFIG.SQUARE_SIZE);
      
      // Resaltar casilla si es necesario
      if (highlight && highlight.r === row && highlight.c === col) {
        ctx.fillStyle = COLORS.highlight;
        ctx.fillRect(col * CONFIG.SQUARE_SIZE, row * CONFIG.SQUARE_SIZE, CONFIG.SQUARE_SIZE, CONFIG.SQUARE_SIZE);
      }
    }
  }
  
  // Dibujar piezas con renderizado optimizado
  drawPieces(fenPieces);
  
  // Dibujar pieza arrastrada si existe
  if (dragState) {
    drawDraggedPiece();
  }
}

function drawPieces(fenPieces) {
  const pieceRows = fenPieces.split('/');
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  
  // Fuente mejorada con mejor renderizado
  const fontSize = CONFIG.SQUARE_SIZE * CONFIG.PIECE_FONT_SIZE;
  ctx.font = `${fontSize}px "Chess Cases", "Chess Merida", "Segoe UI Symbol", "Noto Color Emoji", "Apple Color Emoji", "DejaVu Sans", serif`;
  
  // Configurar renderizado de alta calidad
  ctx.imageSmoothingEnabled = true;
  ctx.imageSmoothingQuality = 'high';
  ctx.textRenderingOptimization = 'optimizeQuality';
  
  for (let row = 0; row < 8; row++) {
    let file = 0;
    for (const char of pieceRows[row]) {
      if (/\d/.test(char)) {
        file += parseInt(char, 10);
      } else {
        const x = (file + 0.5) * CONFIG.SQUARE_SIZE;
        const y = (row + 0.5) * CONFIG.SQUARE_SIZE;
        const isLightSquare = (row + file) % 2 === 0;
        const isWhitePiece = /[PRNBQK]/.test(char);
        
        // Configurar sombra principal
        ctx.shadowColor = COLORS.shadow;
        ctx.shadowBlur = CONFIG.SQUARE_SIZE * CONFIG.SHADOW_BLUR;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = CONFIG.SQUARE_SIZE * 0.015;
        
        // Configurar contorno m√°s definido
        ctx.lineWidth = CONFIG.SQUARE_SIZE * CONFIG.STROKE_WIDTH;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.strokeStyle = isWhitePiece ? COLORS.pieceStrokeWhite : COLORS.pieceStrokeBlack;
        
        // Dibujar contorno
        ctx.strokeText(PIECE_SYMBOLS[char] || '', x, y);
        
        // Crear gradiente para la pieza
        const gradient = ctx.createRadialGradient(x, y - fontSize * 0.15, 0, x, y, fontSize * 0.6);
        if (isWhitePiece) {
          gradient.addColorStop(0, COLORS.pieceWhite);
          gradient.addColorStop(0.7, COLORS.pieceWhiteGradient);
          gradient.addColorStop(1, '#e8e8e8');
        } else {
          gradient.addColorStop(0, COLORS.pieceBlackGradient);
          gradient.addColorStop(0.7, COLORS.pieceBlack);
          gradient.addColorStop(1, '#0f0f0f');
        }
        
        // Dibujar pieza con gradiente
        ctx.shadowBlur = 0;
        ctx.shadowOffsetY = 0;
        ctx.fillStyle = gradient;
        ctx.fillText(PIECE_SYMBOLS[char] || '', x, y);
        
        // A√±adir brillo sutil en casillas claras
        if (isLightSquare && isWhitePiece) {
          ctx.shadowColor = COLORS.shadowLight;
          ctx.shadowBlur = CONFIG.SQUARE_SIZE * 0.03;
          ctx.shadowOffsetY = -CONFIG.SQUARE_SIZE * 0.008;
          ctx.fillStyle = 'rgba(255,255,255,0.4)';
          ctx.fillText(PIECE_SYMBOLS[char] || '', x, y);
          ctx.shadowBlur = 0;
          ctx.shadowOffsetY = 0;
        }
        
        file++;
      }
    }
  }
}

function drawDraggedPiece() {
  if (!dragState) return;
  
  const { piece, x, y } = dragState;
  const isWhitePiece = /[PRNBQK]/.test(piece);
  const fontSize = CONFIG.SQUARE_SIZE * CONFIG.PIECE_FONT_SIZE;
  
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.font = `${fontSize}px "Chess Cases", "Chess Merida", "Segoe UI Symbol", "Noto Color Emoji", "Apple Color Emoji", "DejaVu Sans", serif`;
  
  // Sombra m√°s pronunciada para pieza arrastrada
  ctx.shadowColor = 'rgba(0,0,0,0.7)';
  ctx.shadowBlur = CONFIG.SQUARE_SIZE * (CONFIG.SHADOW_BLUR + 0.04);
  ctx.shadowOffsetX = 0;
  ctx.shadowOffsetY = CONFIG.SQUARE_SIZE * 0.025;
  
  // Contorno m√°s grueso para pieza arrastrada
  ctx.lineWidth = CONFIG.SQUARE_SIZE * (CONFIG.STROKE_WIDTH + 0.02);
  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
  ctx.strokeStyle = isWhitePiece ? 'rgba(0,0,0,0.95)' : 'rgba(255,255,255,0.98)';
  ctx.strokeText(PIECE_SYMBOLS[piece] || '', x, y);
  
  // Crear gradiente para pieza arrastrada con efecto de elevaci√≥n
  const gradient = ctx.createRadialGradient(x, y - fontSize * 0.2, 0, x, y, fontSize * 0.7);
  if (isWhitePiece) {
    gradient.addColorStop(0, 'rgba(255,255,255,0.98)');
    gradient.addColorStop(0.6, 'rgba(248,248,248,0.95)');
    gradient.addColorStop(1, 'rgba(232,232,232,0.92)');
  } else {
    gradient.addColorStop(0, 'rgba(45,45,45,0.98)');
    gradient.addColorStop(0.6, 'rgba(26,26,26,0.95)');
    gradient.addColorStop(1, 'rgba(15,15,15,0.92)');
  }
  
  // Dibujar pieza arrastrada con gradiente y transparencia
  ctx.shadowBlur = 0;
  ctx.shadowOffsetY = 0;
  ctx.fillStyle = gradient;
  ctx.fillText(PIECE_SYMBOLS[piece] || '', x, y);
  
  // A√±adir efecto de brillo para pieza arrastrada
  ctx.shadowColor = 'rgba(255,255,255,0.3)';
  ctx.shadowBlur = CONFIG.SQUARE_SIZE * 0.05;
  ctx.shadowOffsetY = -CONFIG.SQUARE_SIZE * 0.01;
  ctx.fillStyle = isWhitePiece ? 'rgba(255,255,255,0.3)' : 'rgba(255,255,255,0.15)';
  ctx.fillText(PIECE_SYMBOLS[piece] || '', x, y);
  ctx.shadowBlur = 0;
  ctx.shadowOffsetY = 0;
}

function render() {
  // Prevenir bucles de renderizado
  if (typeof render._rendering === 'undefined') {
    render._rendering = false;
  }
  
  if (render._rendering) {
    return;
  }
  
  render._rendering = true;
  
  try {
    const fen = frames[currentIndex] || game.fen();
    drawBoard(fen.split(' ')[0]);
    setStatus(`Posici√≥n ${currentIndex}/${frames.length - 1}`);
  } finally {
    render._rendering = false;
  }
}

/* ============ CONVERSI√ìN DE COORDENADAS ============ */
function algebraicToRC(square) {
  return {
    c: square.charCodeAt(0) - 97,
    r: 8 - parseInt(square[1], 10)
  };
}

function rcToAlgebraic(row, col) {
  return String.fromCharCode(97 + col) + (8 - row);
}

function eventToSquare(event) {
  const rect = canvas.getBoundingClientRect();
  const clientX = event.touches ? event.touches[0].clientX : event.clientX;
  const clientY = event.touches ? event.touches[0].clientY : event.clientY;
  
  const x = clientX - rect.left;
  const y = clientY - rect.top;
  
  // Usar rect.width para mantener proporci√≥n cuadrada
  const size = rect.width;
  const col = Math.min(7, Math.max(0, Math.floor(x / size * 8)));
  const row = Math.min(7, Math.max(0, Math.floor(y / size * 8)));
  
  return { row, col, x: x / size * CONFIG.CANVAS_SIZE, y: y / size * CONFIG.CANVAS_SIZE };
}

/* ============ MANEJO DE EVENTOS T√ÅCTILES Y MOUSE OPTIMIZADO ============ */
function handleStart(event) {
  const square = eventToSquare(event);
  const algebraic = rcToAlgebraic(square.row, square.col);
  const piece = game.get(algebraic);
  
  if (piece) {
    selectedSquare = algebraic;
    dragState = {
      from: algebraic,
      piece: piece.color === 'w' ? piece.type.toUpperCase() : piece.type,
      x: square.x,
      y: square.y
    };
    
    drawBoard(game.fen().split(' ')[0], { r: square.row, c: square.col });
    
    // Feedback t√°ctil
    if ('vibrate' in navigator && isTouch) {
      navigator.vibrate(CONFIG.TOUCH_VIBRATION);
    }
  } else {
    selectedSquare = null;
  }
}

function handleMove(event) {
  if (!dragState || isTouch) return;
  
  const square = eventToSquare(event);
  dragState.x = square.x;
  dragState.y = square.y;
  drawBoard(game.fen().split(' ')[0]);
}

function handleEnd(event) {
  if (!dragState) return;
  
  const square = eventToSquare(event);
  finishMove(dragState.from, rcToAlgebraic(square.row, square.col));
  dragState = null;
  
  if (isTouch) {
    isTouch = false;
  }
}

// Event listeners para mouse - OPTIMIZADOS
canvas.addEventListener('mousedown', (e) => {
  if (isTouch) return;
  handleStart(e);
}, { passive: true });

canvas.addEventListener('mousemove', (e) => {
  if (!dragState || isTouch) return;
  handleMove(e);
}, { passive: true });

canvas.addEventListener('mouseup', (e) => {
  if (!dragState || isTouch) return;
  handleEnd(e);
}, { passive: true });

canvas.addEventListener('mouseleave', () => {
  if (dragState && !isTouch) {
    dragState = null;
    render();
  }
}, { passive: true });

// Event listeners para touch - OPTIMIZADOS
canvas.addEventListener('touchstart', (e) => {
  e.preventDefault();
  isTouch = true;
  touchStartTime = Date.now();
  handleStart(e.touches[0]);
}, { passive: false });

canvas.addEventListener('touchmove', (e) => {
  e.preventDefault();
  if (!dragState) return;
  const square = eventToSquare(e.touches[0]);
  dragState.x = square.x;
  dragState.y = square.y;
  drawBoard(game.fen().split(' ')[0]);
}, { passive: false });

canvas.addEventListener('touchend', (e) => {
  e.preventDefault();
  if (!dragState) return;
  handleEnd(e.changedTouches[0]);
}, { passive: false });

// Click para selecci√≥n - OPTIMIZADO
canvas.addEventListener('click', (e) => {
  if (dragState || isTouch) return;
  
  const square = eventToSquare(e);
  const algebraic = rcToAlgebraic(square.row, square.col);
  
  if (selectedSquare && selectedSquare !== algebraic) {
    finishMove(selectedSquare, algebraic);
    selectedSquare = null;
  } else {
    const piece = game.get(algebraic);
    selectedSquare = piece ? algebraic : null;
    
    if (selectedSquare) {
      drawBoard(game.fen().split(' ')[0], { r: square.row, c: square.col });
    }
  }
}, { passive: true });

/* ============ L√ìGICA DE MOVIMIENTOS ============ */
function needsPromotion(from, to) {
  const piece = game.get(from);
  if (!piece || piece.type !== 'p') return false;
  
  const targetRow = 8 - parseInt(to[1], 10);
  return (piece.color === 'w' && to[1] === '8') || (piece.color === 'b' && to[1] === '1');
}

function finishMove(from, to) {
  if (needsPromotion(from, to)) {
    openPromotionModal((promotion) => {
      tryPerformMove(from, to, promotion);
    });
    return;
  }
  tryPerformMove(from, to);
}

function tryPerformMove(from, to, promotion = 'q') {
  const move = game.move({ from, to, promotion });
  
  if (!move) {
    setStatus('Movimiento ilegal');
    render();
    return;
  }
  
  frames.push(game.fen());
  currentIndex = frames.length - 1;
  render();
  updateMovesDisplay();
  
  if (document.getElementById('auto').checked) {
    scheduleAnalysis();
  }
}

/* ============ MODAL DE PROMOCI√ìN ============ */
function openPromotionModal(callback) {
  const modal = document.getElementById('promo');
  modal.style.display = 'flex';
  
  const handlePromotion = (event) => {
    const promotion = event.target?.dataset?.p;
    if (!promotion) return;
    
    modal.style.display = 'none';
    modal.removeEventListener('click', handlePromotion);
    callback(promotion);
  };
  
  modal.addEventListener('click', handlePromotion);
}

/* ============ CONTROLES DE REPRODUCCI√ìN ============ */
function updateMovesDisplay() {
  const moves = game.history();
  const movesText = moves.map((move, index) => 
    (index % 2 === 0 ? `${Math.floor(index / 2) + 1}. ` : '') + move
  ).join(' ');
  
  document.getElementById('movesBox').textContent = movesText;
  document.getElementById('gameInfo').textContent = `Movidas: ${moves.length}`;
}

// Event listeners para controles - OPTIMIZADOS
document.getElementById('prevBtn').addEventListener('click', () => {
  if (currentIndex > 0) {
    currentIndex--;
    game.load(frames[currentIndex]);
    render();
    if (document.getElementById('auto').checked) {
      scheduleAnalysis();
    }
  }
}, { passive: true });

document.getElementById('nextBtn').addEventListener('click', () => {
  if (currentIndex < frames.length - 1) {
    currentIndex++;
    game.load(frames[currentIndex]);
    render();
    if (document.getElementById('auto').checked) {
      scheduleAnalysis();
    }
  }
}, { passive: true });

document.getElementById('resetBtn').addEventListener('click', () => {
  currentIndex = 0;
  game.load(frames[0]);
  render();
  if (document.getElementById('auto').checked) {
    scheduleAnalysis();
  }
}, { passive: true });

document.getElementById('playBtn').addEventListener('click', () => {
  if (isPlaying) {
    clearInterval(playTimer);
    isPlaying = false;
    document.getElementById('playBtn').textContent = '‚ñ∂ Play';
    return;
  }
  
  isPlaying = true;
  document.getElementById('playBtn').textContent = '‚è∏ Pausa';
  
  const speed = Math.max(100, parseInt(document.getElementById('speed').value) || 800);
  playTimer = setInterval(() => {
    if (currentIndex < frames.length - 1) {
      currentIndex++;
      game.load(frames[currentIndex]);
      render();
      if (document.getElementById('auto').checked) {
        scheduleAnalysis();
      }
    } else {
      clearInterval(playTimer);
      isPlaying = false;
      document.getElementById('playBtn').textContent = '‚ñ∂ Play';
    }
  }, speed);
}, { passive: true });

/* ============ MODO NI√ëOS/ADULTOS ============ */
function toggleChildMode() {
  isChildMode = !isChildMode;
  document.body.classList.toggle('child-mode', isChildMode);
  
  const indicator = document.getElementById('modeIndicator');
  const toggleBtn = document.getElementById('modeToggle');
  
  if (isChildMode) {
    indicator.textContent = 'Modo Ni√±os';
    toggleBtn.textContent = 'üë® Modo Adultos';
    setStatus('Modo Ni√±os activado - Colores m√°s suaves');
  } else {
    indicator.textContent = 'Modo Adultos';
    toggleBtn.textContent = 'üë∂ Modo Ni√±os';
    setStatus('Modo Adultos activado');
  }
  
  // Re-renderizar con nuevos colores
  render();
}

document.getElementById('modeToggle').addEventListener('click', toggleChildMode, { passive: true });

/* ============ IMPORTACI√ìN PGN ============ */
function cleanPGN(text) {
  return text
    .replace(/^\uFEFF/, '') // BOM
    .replace(/\r\n?/g, '\n') // Normalizar saltos de l√≠nea
    .replace(/\$\d+/g, '') // NAGs
    .replace(/\{[^}]*\}/g, '') // Comentarios {...}
    .replace(/\([^()]*\)/g, '') // Variantes simples
    .replace(/\n{3,}/g, '\n\n') // M√∫ltiples saltos de l√≠nea
    .trim();
}

function splitGames(rawText) {
  const text = cleanPGN(rawText);
  const indices = [];
  const regex = /\n(?=\[Event\s*")|^\[Event\s*"/gm;
  let match;
  
  while ((match = regex.exec(text))) {
    indices.push(match.index);
  }
  
  if (!indices.length) return [text];
  
  const games = [];
  for (let i = 0; i < indices.length; i++) {
    const start = indices[i];
    const end = indices[i + 1] ?? text.length;
    games.push(text.slice(start, end).trim());
  }
  
  return games.filter(Boolean);
}

function getGameTitle(pgn) {
  const event = (pgn.match(/\[Event\s*"([^"]*)"\]/) || [])[1] || 'Partida';
  const date = (pgn.match(/\[Date\s*"([^"]*)"\]/) || [])[1] || '';
  const white = (pgn.match(/\[White\s*"([^"]*)"\]/) || [])[1] || '';
  const black = (pgn.match(/\[Black\s*"([^"]*)"\]/) || [])[1] || '';
  
  return `${event} ‚Äî ${white} vs ${black} ${date ? `(${date})` : ''}`.trim();
}

function importPGNCollection(rawText) {
  const games = splitGames(rawText);
  
  if (!games.length) {
    alert('No se encontraron partidas en el archivo.');
    return;
  }
  
  // Configurar selector de partidas
  const selector = document.getElementById('gameSelect');
  selector.innerHTML = '';
  
  games.forEach((game, index) => {
    const option = document.createElement('option');
    option.value = index;
    option.textContent = getGameTitle(game);
    selector.appendChild(option);
  });
  
  const count = document.getElementById('gameCount');
  count.textContent = games.length > 1 ? `(${games.length})` : '';
  
  const picker = document.getElementById('gamePicker');
  picker.style.display = games.length > 1 ? 'flex' : 'none';
  
  selector.addEventListener('change', () => loadPGN(games[parseInt(selector.value)], true), { passive: true });
  
  // Cargar primera partida autom√°ticamente
  loadPGN(games[0], true);
}

function loadPGN(pgn, reset = true) {
  const success = game.load_pgn(pgn, { sloppy: true });
  
  if (!success) {
    alert('PGN inv√°lido.');
    return false;
  }
  
  // Reconstruir frames
  const moves = game.history();
  game.reset();
  frames = [game.fen()];
  
  for (const move of moves) {
    game.move(move);
    frames.push(game.fen());
  }
  
  currentIndex = 0;
  render();
  updateMovesDisplay();
  
  if (document.getElementById('auto').checked) {
    scheduleAnalysis();
  }
  
  if (reset) {
    setStatus('Partida cargada.');
  }
  
  return true;
}

// Event listeners para importaci√≥n - OPTIMIZADOS
document.getElementById('file').addEventListener('change', async () => {
  const file = document.getElementById('file').files?.[0];
  if (!file) return;
  
  try {
    const text = await file.text();
    importPGNCollection(text);
  } catch (error) {
    log('Error al leer archivo: ' + error.message, 'error');
    alert('Error al leer el archivo.');
  }
}, { passive: true });

document.getElementById('loadTextBtn').addEventListener('click', () => {
  const text = document.getElementById('pgnText').value;
  if (text.trim()) {
    importPGNCollection(text);
  } else {
    alert('Por favor, pega un PGN en el √°rea de texto.');
  }
}, { passive: true });

document.getElementById('copyFenBtn').addEventListener('click', async () => {
  const fen = frames[currentIndex] || game.fen();
  
  try {
    await navigator.clipboard.writeText(fen);
    setStatus('FEN copiado al portapapeles.');
  } catch (error) {
    log('Error al copiar FEN: ' + error.message, 'error');
    setStatus('Error al copiar FEN.');
  }
}, { passive: true });

/* ============ MOTOR STOCKFISH OPTIMIZADO ============ */
function ensureEngine() {
  if (engine) return engine;
  
  // Intentar motor local primero
  try {
    engine = new Worker(ENGINE_SOURCES[0]);
    engine.onmessage = handleEngineMessage;
    engine.onerror = (error) => {
      log('Error cargando motor local: ' + error.message, 'warn');
      loadCDNEngine();
    };
    return engine;
  } catch (error) {
    log('No se pudo cargar motor local, usando CDN', 'warn');
    return loadCDNEngine();
  }
}

function loadCDNEngine() {
  const code = `
    self.onerror = e => postMessage({type:'sf-error', msg:String(e && e.message || e)});
    let loaded = false;
    ${ENGINE_SOURCES.slice(1).map((url, i) => `
    if (!loaded) {
      try { 
        importScripts('${url}'); 
        postMessage({type:'sf-ok', src:'CDN ${i+1}'}); 
        loaded = true;
      } catch(e) { console.warn('Fall√≥ CDN ${i+1}:', e); }
    }`).join('')}
    if (!loaded) {
      postMessage({type:'sf-error', msg:'No se pudo cargar Stockfish desde ning√∫n CDN.'});
    }
  `;
  
  const blob = new Blob([code], { type: 'application/javascript' });
  engine = new Worker(URL.createObjectURL(blob));
  engine.onmessage = handleEngineMessage;
  return engine;
}

function handleEngineMessage(event) {
  const data = event.data;
  
  if (data?.type === 'sf-ok') {
    engineReady = true;
    document.getElementById('engineSrc').textContent = ` (motor: ${data.src})`;
    setStatus('Motor de ajedrez listo.');
    return;
  }
  
  if (data?.type === 'sf-error') {
    log('Error del motor: ' + data.msg, 'error');
    showEvaluation('‚Äî', '‚Äî', '‚Äî');
    document.getElementById('engineSrc').textContent = ' (motor: error)';
    setStatus('Error: Motor no disponible');
    isAnalyzing = false;
    return;
  }
  
  // Manejar bestmove
  if (typeof data === 'string' && data.startsWith('bestmove')) {
    isAnalyzing = false;
    setStatus('An√°lisis completado');
    return;
  }
  
  const line = typeof data === 'string' ? data : (data?.data || '');
  if (!line || !line.startsWith('info ')) return;
  
  const depth = parseInt((line.match(/\bdepth\s+(\d+)/) || [])[1]) || lastDepth;
  const cp = (line.match(/\bcp\s+(-?\d+)/) || [])[1];
  const mate = (line.match(/\bmate\s+(-?\d+)/) || [])[1];
  const pv = (line.match(/\bpv\s+(.+)/) || [])[1] || '';
  
  if (depth < lastDepth) return;
  
  lastDepth = depth;
  const evaluation = mate ? `#${mate}` : (cp ? (parseInt(cp) / 100).toFixed(2) : '‚Äî');
  const bestMove = pv.split(' ')[0] || '‚Äî';
  
  if (bestMove !== lastBest) {
    lastBest = bestMove;
  }
  
  showEvaluation(evaluation, depth, uciToNice(bestMove));
  showPrincipalVariation(pv);
  
  const maxDepth = Math.max(6, Math.min(30, parseInt(document.getElementById('maxDepth').value) || CONFIG.MAX_DEPTH_DESKTOP));
  const progress = Math.min(100, Math.round(depth / maxDepth * 100));
  document.getElementById('depthBar').style.width = `${progress}%`;
}

function uciToNice(uci) {
  if (!uci || uci === '‚Äî') return '‚Äî';
  
  const figurines = { p: '', n: '‚ôò', b: '‚ôó', r: '‚ôñ', q: '‚ôï', k: '‚ôî' };
  const from = uci.slice(0, 2);
  const to = uci.slice(2, 4);
  const promotion = uci[4];
  
  const piece = game.get(from);
  const fig = piece ? figurines[piece.type] || '' : '';
  const promoFig = promotion ? '=' + PROMOTION_PIECES[promotion] || promotion.toUpperCase() : '';
  
  return fig + from + '‚Äì' + to + promoFig;
}

function showEvaluation(eval, depth, bestMove) {
  const box = document.getElementById('evalBox');
  const srcSpan = document.getElementById('engineSrc');
  
  box.innerHTML = `Eval: ${eval} | Profundidad: ${depth} | Mejor jugada: ${bestMove} `;
  
  if (srcSpan) {
    box.appendChild(srcSpan);
  } else {
    const src = document.createElement('span');
    src.id = 'engineSrc';
    src.className = 'note';
    box.appendChild(src);
  }
}

function showPrincipalVariation(pv) {
  const tokens = pv.trim().split(/\s+/).slice(0, 80);
  const display = tokens.map(uciToNice).join(' ');
  document.getElementById('pvBox').textContent = display || '‚Äî';
}

function scheduleAnalysis() {
  if (isAnalyzing) return;
  
  clearTimeout(analysisTimer);
  analysisTimer = setTimeout(() => {
    if (!isAnalyzing) {
      runAnalysis();
    }
  }, CONFIG.ANALYSIS_DELAY);
}

function runAnalysis() {
  try {
    if (isAnalyzing) {
      setStatus('An√°lisis en curso...');
      return;
    }
    
    isAnalyzing = true;
    ensureEngine();
    
    if (!engine) {
      setStatus('Error: No se pudo inicializar el motor');
      isAnalyzing = false;
      return;
    }
    
    lastDepth = 0;
    lastBest = '';
    
    const maxDepth = Math.max(6, Math.min(30, parseInt(document.getElementById('maxDepth').value) || CONFIG.MAX_DEPTH_DESKTOP));
    const multiPV = Math.max(1, Math.min(3, parseInt(document.getElementById('multipv').value) || 1));
    const fen = frames[currentIndex] || game.fen();
    
    if (!fen || fen.split(' ').length < 4) {
      setStatus('Error: Posici√≥n inv√°lida');
      isAnalyzing = false;
      return;
    }
    
    showEvaluation('‚Ä¶', '‚Äî', '‚Äî');
    showPrincipalVariation('Pensando‚Ä¶');
    setStatus('Analizando posici√≥n...');
    
    // Enviar comandos al motor
    const commands = [
      'uci',
      `setoption name MultiPV value ${multiPV}`,
      'isready',
      'ucinewgame',
      `position fen ${fen}`,
      `go depth ${maxDepth}`
    ];
    
    commands.forEach((cmd, index) => {
      setTimeout(() => {
        if (engine && isAnalyzing) {
          engine.postMessage(cmd);
        }
      }, index * 10);
    });
    
  } catch (error) {
    log('Error en an√°lisis: ' + error.message, 'error');
    setStatus('Error en an√°lisis: ' + error.message);
    isAnalyzing = false;
  }
}

// Event listeners para an√°lisis - OPTIMIZADOS
document.getElementById('goBtn').addEventListener('click', runAnalysis, { passive: true });

document.getElementById('stopBtn').addEventListener('click', () => {
  if (engine) {
    engine.postMessage('stop');
    isAnalyzing = false;
    setStatus('An√°lisis detenido');
  }
}, { passive: true });

/* ============ INICIALIZACI√ìN OPTIMIZADA ============ */
function initialize() {
  // Configurar canvas para alta calidad primero
  setupCanvasQuality();
  
  frames = [game.fen()];
  currentIndex = 0;
  render();
  updateMovesDisplay();
  
  // Detectar dispositivo m√≥vil
  const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  
  if (isMobile) {
    document.body.classList.add('mobile');
    document.getElementById('maxDepth').value = CONFIG.MAX_DEPTH_MOBILE;
    setStatus('Modo m√≥vil activado');
  }
  
  // Precargar motor en segundo plano
  setTimeout(() => {
    try {
      ensureEngine();
    } catch (error) {
      log('No se pudo precargar el motor: ' + error.message, 'warn');
    }
  }, 1000);
  
  setStatus('Visor PGN listo');
}

// Event listener para carga - OPTIMIZADO
window.addEventListener('load', initialize, { passive: true });

// Manejar cambios de visibilidad - OPTIMIZADO
document.addEventListener('visibilitychange', () => {
  if (document.hidden && isAnalyzing) {
    if (engine) {
      engine.postMessage('stop');
      isAnalyzing = false;
    }
  }
}, { passive: true });

// Manejar errores globales - OPTIMIZADO
window.addEventListener('error', (event) => {
  log('Error global: ' + (event.error?.message || event.message), 'error');
}, { passive: true });

window.addEventListener('unhandledrejection', (event) => {
  log('Promise rechazada: ' + event.reason, 'error');
}, { passive: true });

// Prevenir zoom en m√≥viles
document.addEventListener('touchstart', (e) => {
  if (e.touches.length > 1) {
    e.preventDefault();
  }
}, { passive: false });

// Optimizar para iframe (GitHub Pages/Hostinger)
if (window.parent !== window) {
  document.body.classList.add('iframe-mode');
  // Ajustar estilos para iframe si es necesario
}
</script>
<script defer src="./main.js?v=3"></script>

</body>
</html>
