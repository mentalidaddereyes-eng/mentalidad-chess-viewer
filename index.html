<script>
/* ====== Base ====== */
const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d', {alpha:true});

// **CORRECCIÃ“N: Ya no usamos un tamaÃ±o fijo, solo la variable S (tamaÃ±o de la celda)**
let S; 
const GLYPH = {'P':'â™™','N':'â™˜','B':'â™—','R':'â™–','Q':'â™•','K':'â™”','p':'â™Ÿ','n':'â™','b':'â™','r':'â™œ','q':'â™›','k':'â™š'};
function CSS(v){ return getComputedStyle(document.documentElement).getPropertyValue(v).trim(); }
const COLORS = ()=>({ light:CSS('--sq-light'), dark:CSS('--sq-dark') });

let game = new Chess();
let frames = [game.fen()], idx=0;
let playing=false, timer=null;
let selSquare=null, drag=null;
let lastMove=null, bestArrow=null;

// **CORRECCIÃ“N: Estado para el flickering**
let currentFen=null; 

/* ====== Modo ====== */
const modeSel = document.getElementById('modeSel');
function statusMsg(t){ document.getElementById('status').textContent=t; }
function applyMode(m){
Â  document.body.classList.remove('kids','adult');
Â  document.body.classList.add(m);
Â  statusMsg(m==='kids' ? 'Â¡Listo para jugar! ğŸŒŸ Arrastra o toca para mover.' : 'Tablero listo. Arrastra o haz click-click para mover.');
Â  render();
}
modeSel.onchange = ()=>applyMode(modeSel.value);
applyMode('kids');

/* ====== Dibujo ====== */
function drawBoard(fenPieces){
Â  const C = COLORS();
Â  for(let r=0;r<8;r++){
Â  Â  for(let c=0;c<8;c++){
Â  Â  Â  const light = (r+c)%2===0;
Â  Â  Â  ctx.fillStyle = light? C.light : C.dark;
Â  Â  Â  ctx.fillRect(c*S, r*S, S, S);
Â  Â  }
Â  }
Â  if(lastMove){
Â  Â  const a=alg2rc(lastMove.from), b=alg2rc(lastMove.to);
Â  Â  ctx.fillStyle=CSS('--hl-last');
Â  Â  ctx.fillRect(a.c*S,a.r*S,S,S); ctx.fillRect(b.c*S,b.r*S,S,S);
Â  }
Â  const rows = fenPieces.split('/');
Â  ctx.textAlign='center'; ctx.textBaseline='middle';
Â  ctx.font = `${S*0.74}px "Segoe UI Symbol","Noto Color Emoji","Apple Color Emoji",serif`;
Â  for(let r=0;r<8;r++){
Â  Â  let f=0;
Â  Â  for(const ch of rows[r]){
Â  Â  Â  if(/\d/.test(ch)){ f += +ch; }
Â  Â  Â  else{
Â  Â  Â  Â  const x=(f+0.5)*S, y=(r+0.5)*S;
Â  Â  Â  Â  const lightSq = (r+f)%2===0;
Â  Â  Â  Â  ctx.lineWidth = S*0.06;
Â  Â  Â  Â  ctx.strokeStyle = lightSq? 'rgba(0,0,0,.85)' : 'rgba(255,255,255,.9)';
Â  Â  Â  Â  ctx.shadowColor='rgba(0,0,0,.35)'; ctx.shadowBlur=S*0.05;
Â  Â  Â  Â  ctx.strokeText(GLYPH[ch]||'', x, y); ctx.shadowBlur=0;
Â  Â  Â  Â  ctx.fillStyle = /[PRNBQK]/.test(ch)? '#ffffff' : '#0b1120';
Â  Â  Â  Â  ctx.fillText(GLYPH[ch]||'', x, y);
Â  Â  Â  Â  f++;
Â  Â  Â  }
Â  Â  }
Â  }
Â  if(bestArrow) drawArrow(bestArrow.from,bestArrow.to,'rgba(28,199,86,.9)');
Â  if(drag){
Â  Â  const {piece,x,y}=drag;
Â  Â  ctx.lineWidth=S*0.06; ctx.strokeStyle='rgba(0,0,0,.85)';
Â  Â  ctx.shadowColor='rgba(0,0,0,.35)'; ctx.shadowBlur=S*0.05;
Â  Â  
    // **CORRECCIÃ“N CLAVE: Dibujar el arrastre usando las coordenadas ESCALADAS del drag**
    // Se usa 'x' e 'y' directamente del objeto drag, ya que `ctx.scale()` fue llamado en `resizeBoard`.
Â  Â  ctx.strokeText(GLYPH[piece]||'', x, y); 
Â  Â  ctx.shadowBlur=0;
Â  Â  ctx.fillStyle=/[PRNBQK]/.test(piece)? '#ffffff' : '#0b1120';
Â  Â  ctx.fillText(GLYPH[piece]||'', x, y);
Â  }
}
function drawArrow(fromSq,toSq,color){
Â  const a=alg2rc(fromSq), b=alg2rc(toSq);
Â  const A={x:(a.c+0.5)*S,y:(a.r+0.5)*S}, B={x:(b.c+0.5)*S,y:(b.r+0.5)*S};
Â  ctx.strokeStyle=color; ctx.lineWidth=Math.max(4,S*0.06); ctx.lineCap='round';
Â  ctx.beginPath(); ctx.moveTo(A.x,A.y); ctx.lineTo(B.x,B.y); ctx.stroke();
Â  const ang=Math.atan2(B.y-A.y,B.x-A.x), L=Math.max(18,S*0.35);
Â  ctx.beginPath(); ctx.moveTo(B.x,B.y);
Â  ctx.lineTo(B.x-L*Math.cos(ang-Math.PI/6),B.y-L*Math.sin(ang-Math.PI/6));
Â  ctx.lineTo(B.x-L*Math.cos(ang+Math.PI/6),B.y-L*Math.sin(ang+Math.PI/6));
Â  ctx.closePath(); ctx.fillStyle=color; ctx.fill();
}

// **CORRECCIÃ“N: LÃ³gica de redimensionamiento (Responsiveness)**
function resizeBoard() {
Â  const canvasBox = document.getElementById('canvasBox');
Â  const cssSize = canvasBox.clientWidth || 300;
Â  const scale = window.devicePixelRatio || 1; 
Â  
Â  canvas.style.width = cssSize + 'px';
Â  canvas.style.height = cssSize + 'px';
Â  
Â  canvas.width = Math.round(cssSize * scale);
Â  canvas.height = Math.round(cssSize * scale);
Â  
Â  S = canvas.width / (8 * scale); // S se calcula con el tamaÃ±o CSS (no escalado)
Â  
Â  ctx.setTransform(1, 0, 0, 1, 0, 0); // Resetear transformaciÃ³n
Â  ctx.scale(scale, scale); // Reajustar la escala para el dibujo
Â  
Â  render();
}
function render(){ 
Â  drawBoard((frames[idx]||game.fen()).split(' ')[0]); 
Â  statusMsg(`PosiciÃ³n ${idx}/${frames.length-1}`); 
}

function alg2rc(sq){ return {c: sq.charCodeAt(0)-97, r: 8-parseInt(sq[1],10)} }
function rc2alg(r,c){ return String.fromCharCode(97+c)+(8-r) }

function evt2sq(ev){
Â  const rect=canvas.getBoundingClientRect();
Â  const x=(ev.touches?ev.touches[0].clientX:ev.clientX)-rect.left;
Â  const y=(ev.touches?ev.touches[0].clientY:ev.clientY)-rect.top;
Â  const c=Math.min(7,Math.max(0,Math.floor(x/rect.width*8)));
Â  const r=Math.min(7,Math.max(0,Math.floor(y/rect.height*8)));
Â  
Â  // **CORRECCIÃ“N: Coordenadas de arrastre deben ser relativas al tamaÃ±o CSS para que ctx.scale() las maneje**
Â  const realWidth = rect.width / canvas.width * canvas.width; // Esto es canvas.clientWidth
Â  const realHeight = rect.height / canvas.height * canvas.height; // Esto es canvas.clientHeight

Â  // Se devuelve la coordenada X, Y relativa al tamaÃ±o CSS (no escalado), que es lo que espera ctx.scale()
Â  return {r,c,x: x/rect.width*realWidth, y: y/rect.height*realHeight};
}

/* ====== Movimiento (drag + click) + promociÃ³n ====== */
canvas.addEventListener('mousedown', e=>{
Â  const q=evt2sq(e), sq=rc2alg(q.r,q.c), piece=game.get(sq);
Â  if(piece){ selSquare=sq; drag={from:sq, piece:(piece.color==='w'?piece.type.toUpperCase():piece.type), x:q.x,y:q.y}; render(); }
Â  else selSquare=null;
});
canvas.addEventListener('mousemove', e=>{ if(!drag) return; const q=evt2sq(e); drag.x=q.x; drag.y=q.y; render(); });
canvas.addEventListener('mouseup', e=>{ if(!drag) return; const q=evt2sq(e); finishMove(drag.from, rc2alg(q.r,q.c)); drag=null; });
canvas.addEventListener('mouseleave', ()=>{ if(drag){ drag=null; render(); }});

// **LÃ³gica TÃ¡ctil**
canvas.addEventListener('touchstart', e=>{ 
  if(e.touches.length > 1) return;
  e.preventDefault(); 
  canvas.dispatchEvent(new MouseEvent('mousedown',{
    clientX:e.touches[0].clientX, 
    clientY:e.touches[0].clientY,
    bubbles: true, cancelable: true 
  }));
}, {passive:false});

canvas.addEventListener('touchmove', e=>{ 
  if(e.touches.length > 1) return;
  e.preventDefault(); 
  canvas.dispatchEvent(new MouseEvent('mousemove',{
    clientX:e.touches[0].clientX, 
    clientY:e.touches[0].clientY,
    bubbles: true, cancelable: true 
  }));
}, {passive:false});

canvas.addEventListener('touchend', e=>{ 
  e.preventDefault(); 
  if(e.changedTouches.length === 0) return;
  const lastTouch = e.changedTouches[0];
  
  if(drag){
    canvas.dispatchEvent(new MouseEvent('mouseup',{
      clientX: lastTouch.clientX, 
      clientY: lastTouch.clientY,
      bubbles: true, cancelable: true 
    }));
  } else {
    canvas.dispatchEvent(new MouseEvent('click',{
      clientX: lastTouch.clientX, 
      clientY: lastTouch.clientY,
      bubbles: true, cancelable: true 
    }));
  }
}, {passive:false});

canvas.addEventListener('click', e=>{
Â  if(drag) return;
Â  const q=evt2sq(e), sq=rc2alg(q.r,q.c);
Â  if(selSquare && selSquare!==sq){ finishMove(selSquare, sq); selSquare=null; }
Â  else { const piece=game.get(sq); selSquare = piece? sq : null; }
});
function needsPromo(from,to){
Â  const p=game.get(from); if(!p||p.type!=='p') return false;
Â  return (p.color==='w'&&to[1]==='8')||(p.color==='b'&&to[1]==='1');
}
const promo = document.getElementById('promo');
function openPromo(cb){
Â  promo.style.display='flex';
Â  const handler=e=>{
Â  Â  const p=e.target?.dataset?.p; if(!p) return;
Â  Â  promo.style.display='none'; promo.removeEventListener('click',handler); cb(p);
Â  };
Â  promo.addEventListener('click',handler);
}
function finishMove(from,to){ if(needsPromo(from,to)){ openPromo(p=>tryMove(from,to,p)); } else tryMove(from,to); }
function tryMove(from,to,p){
Â  const mv=game.move({from,to,promotion:p||'q'});
Â  if(!mv){ statusMsg(modeSel.value==='kids'?'Â¡Esa no vale! ğŸš«':'Movimiento ilegal'); render(); return; }
Â  lastMove={from:mv.from,to:mv.to}; bestArrow=null;
Â  frames.push(game.fen()); idx=frames.length-1; render(); updateMoves();
Â  if(document.getElementById('auto').checked) scheduleAnalysis();
}

/* ====== ReproducciÃ³n ====== */
prevBtn.onclick = ()=>{ if(idx>0){ idx--; game.load(frames[idx]); lastMove=rebuildLast(idx); render(); if(auto.checked) scheduleAnalysis(); } };
nextBtn.onclick = ()=>{ if(idx<frames.length-1){ idx++; game.load(frames[idx]); lastMove=rebuildLast(idx); render(); if(auto.checked) scheduleAnalysis(); } };
resetBtn.onclick = ()=>{ idx=0; game.load(frames[0]); lastMove=null; bestArrow=null; render(); if(auto.checked) scheduleAnalysis(); };
playBtn.onclick = ()=>{
Â  if(playing){ clearInterval(timer); playing=false; playBtn.textContent='â–¶ Play'; return; }
Â  playing=true; playBtn.textContent='â¸ Pausa';
Â  const ms=Math.max(100,+document.getElementById('speed').value||800);
Â  timer=setInterval(()=>{
Â  Â  if(idx<frames.length-1){ idx++; game.load(frames[idx]); lastMove=rebuildLast(idx); render(); if(auto.checked) scheduleAnalysis(); }
Â  Â  else{ clearInterval(timer); playing=false; playBtn.textContent='â–¶ Play'; }
Â  }, ms);
};
function rebuildLast(k){
Â  if(k<=0) return null;
Â  const san=game.history(); const g=new Chess(); let prev=null;
Â  for(let i=0;i<k;i++){ prev=g.move(san[i]); }
Â  return prev?{from:prev.from,to:prev.to}:null;
}

/* ====== PGN (archivo/textarea/drag&drop) ====== */
const file=document.getElementById('file'), pgnText=document.getElementById('pgnText');
document.getElementById('loadTextBtn').onclick=()=>importPGNCollection(pgnText.value);
file.onchange=async()=>{ const f=file.files?.[0]; if(!f) return; importPGNCollection(await f.text()); };
['dragenter','dragover'].forEach(ev=>{
Â  canvas.addEventListener(ev, e=>{ e.preventDefault(); canvas.style.outline='3px dashed #69a24a'; });
});
['dragleave','drop'].forEach(ev=>{
Â  canvas.addEventListener(ev, e=>{ e.preventDefault(); canvas.style.outline='none'; });
});
canvas.addEventListener('drop', async (e)=>{
Â  const f=e.dataTransfer.files?.[0]; if(!f) return;
Â  if(!/\.pgn|\.txt$/i.test(f.name)){ alert('Arrastra un archivo .pgn o .txt'); return; }
Â  importPGNCollection(await f.text());
});
function cleanPGN(txt){
Â  return (txt||'')
Â  Â .replace(/^\uFEFF/,'').replace(/\r\n?/g,'\n')
Â  Â .replace(/\$\d+/g,'').replace(/\{[^}]*\}/g,'')
Â  Â .replace(/\([^()]*\)/g,'').replace(/\n{3,}/g,'\n\n').trim();
}
function splitGames(raw){
Â  const txt=cleanPGN(raw); const idxs=[]; const re=/\n(?=\[Event\s*")|^\[Event\s*"/gm; let m;
Â  while((m=re.exec(txt))) idxs.push(m.index);
Â  if(!idxs.length) return [txt];
Â  const out=[]; for(let i=0;i<idxs.length;i++){ const a=idxs[i], b=idxs[i+1]??txt.length; out.push(txt.slice(a,b).trim()); }
Â  return out.filter(Boolean);
}
function gameTitle(pgn){
Â  const e=(pgn.match(/\[Event\s*"([^"]*)"\]/)||[])[1]||'Partida';
Â  const d=(pgn.match(/\[Date\s*"([^"]*)"\]/)||[])[1]||'';
Â  const w=(pgn.match(/\[White\s*"([^"]*)"\]/)||[])[1]||''; const b=(pgn.match(/\[Black\s*"([^"]*)"\]/)||[])[1]||'';
Â  return `${e} â€” ${w} vs ${b} ${d?`(${d})`:''}`.trim();
}
function importPGNCollection(raw){
Â  const games=splitGames(raw); if(!games.length){ alert('No se encontraron partidas en el archivo.'); return; }
Â  const sel=document.getElementById('gameSelect'); sel.innerHTML='';
Â  games.forEach((g,i)=>{ const o=document.createElement('option'); o.value=i; o.textContent=gameTitle(g); sel.appendChild(o); });
Â  document.getElementById('gameCount').textContent=games.length>1?`(${games.length})`:'';
Â  document.getElementById('gamePicker').style.display=games.length>1?'flex':'none';
Â  sel.onchange=()=>loadPGN(games[+sel.value],true);
Â  loadPGN(games[0],true);
}
function loadPGN(pgn,reset=true){
Â  const ok=game.load_pgn(pgn,{sloppy:true}); if(!ok){ alert('PGN invÃ¡lido.'); return false; }
Â  const san=game.history(); game.reset(); frames=[game.fen()]; let mv=null;
Â  for(const m of san){ mv=game.move(m); frames.push(game.fen()); }
Â  idx=frames.length-1; lastMove=mv?{from:mv.from,to:mv.to}:null; bestArrow=null;
Â  render(); updateMoves(); if(auto.checked) scheduleAnalysis();
Â  if(reset) statusMsg('Partida cargada.');
Â  return true;
}
function updateMoves(){
Â  const san=game.history(); const box=document.getElementById('movesBox'); box.innerHTML='';
Â  const g2=new Chess(); const fens=[g2.fen()]; san.forEach(m=>{ g2.move(m); fens.push(g2.fen()); });
Â  san.forEach((m,i)=>{
Â  Â  if(i%2===0){ const turn=document.createElement('span'); turn.className='note'; turn.textContent=(Math.floor(i/2)+1)+'. '; box.appendChild(turn); }
Â  Â  const sp=document.createElement('span'); sp.textContent=m+' '; sp.style.cursor='pointer';
Â  Â  sp.onclick=()=>{ idx=i+1; game.load(fens[idx]); const g3=new Chess(); let prev=null; for(let k=0;k<=i;k++) prev=g3.move(san[k]);
Â  Â  Â  lastMove=prev?{from:prev.from,to:prev.to}:null; bestArrow=null; render(); if(auto.checked) scheduleAnalysis(); };
Â  Â  box.appendChild(sp);
Â  });
Â  document.getElementById('gameInfo').textContent=`Movidas: ${san.length}`;
}
document.getElementById('copyFenBtn').onclick=async()=>{
Â  const fen=frames[idx]||game.fen(); await navigator.clipboard.writeText(fen);
Â  statusMsg(modeSel.value==='kids'?'Â¡FEN copiado! ğŸ“‹':'FEN copiado.');
};

/* ====== Motor (Stockfish en Worker) ====== */
let engine=null, lastDepth=0, lastUi=0;
const UI_MS=400;
const MIRRORS=[
Â 'https://cdnjs.cloudflare.com/ajax/libs/stockfish.js/9.0.0/stockfish.min.js',
Â 'https://cdnjs.cloudflare.com/ajax/libs/stockfish.js/9.0.0/stockfish.js'
];
function ensureEngine(){
Â  if(engine) return engine;
Â  const code=`self.onerror=e=>postMessage({type:'sf-error',msg:String(e&&e.message||e)});
try{importScripts('${MIRRORS[0]}');postMessage({type:'sf-ok',src:'CDNJS'});}
catch(e){try{importScripts('${MIRRORS[1]}');postMessage({type:'sf-ok',src:'CDNJS fallback'});}
catch(err){postMessage({type:'sf-error',msg:'No se pudo cargar Stockfish.'});}}`;
Â  engine=new Worker(URL.createObjectURL(new Blob([code],{type:'application/javascript'})));
Â  engine.onmessage=onEngineMessage; return engine;
}
function onEngineMessage(e){
Â  const d=e.data;
Â  if(d?.type==='sf-ok'){ const s=document.getElementById('engineSrc'); if(s) s.textContent=` (motor: ${d.src})`; return; }
Â  if(d?.type==='sf-error'){ showEval('â€”','â€”','â€”'); const s=document.getElementById('engineSrc'); if(s) s.textContent=' (motor: error)'; return; }

Â  // **CORRECCIÃ“N: Evitar flickering/saltos si el FEN actual es diferente**
Â  const currentDisplayedFen = frames[idx] || game.fen();
Â  if (currentFen !== currentDisplayedFen) return; 
Â  
Â  const line=(typeof d==='string')?d:(d?.data||''); if(!line||!line.startsWith('info ')) return;

Â  const depth=+(line.match(/\bdepth\s+(\d+)/)||[])[1]||lastDepth;
Â  if(depth<lastDepth) return;
Â  const now=performance.now(); if(now-lastUi<UI_MS && depth===lastDepth) return;
Â  lastDepth=depth; lastUi=now;

Â  const cp=(line.match(/\bcp\s+(-?\d+)/)||[])[1];
Â  const mate=(line.match(/\bmate\s+(-?\d+)/)||[])[1];
Â  const pv=(line.match(/\bpv\s+(.+)/)||[])[1]||'';
Â  const best=pv.split(' ')[0]||'â€”';

Â  // **CORRECCIÃ“N: Calcular evaluaciÃ³n numÃ©rica para pasar a showEval**
Â  let rawEval = 'â€”';
Â  if (mate) {
Â  Â  rawEval = '#' + mate;
Â  } else if (cp) {
Â  Â  const value = Number(cp) / 100;
Â  Â  const turn = currentFen.split(' ')[1];
Â  Â  // Asegurar que el valor es relativo al jugador que mueve
Â  Â  rawEval = (turn === 'w' ? value : -value).toFixed(2);
Â  }
Â  
Â  showEval(rawEval, depth, uciToNice(best));
Â  showPV(pv);

Â  const dMax=Math.max(6,Math.min(30,+document.getElementById('maxDepth').value||18));
Â  document.getElementById('depthBar').style.width=`${Math.min(100,Math.round(depth/dMax*100))}%`;

Â  if(best.length>=4){ bestArrow={from:best.slice(0,2),to:best.slice(2,4)}; render(); }
}
function uciToNice(uci){
Â  if(!uci||uci==='â€”') return 'â€”';
Â  const figs={p:'',n:'â™˜',b:'â™—',r:'â™–',q:'â™•',k:'â™”'};
Â  const from=uci.slice(0,2), to=uci.slice(2,4), pr=uci[4];
Â  const piece=game.get(from); const fig=piece?(figs[piece.type]||''):'';
Â  const promo=pr?('='+({q:'â™•',r:'â™–',b:'â™—',n:'â™˜'}[pr]||pr.toUpperCase())):'';
Â  return fig+from+'â€“'+to+promo;
}
function humanEval(v){
Â  if(v==='â€”') return 'Pensandoâ€¦ ğŸ¤”';
Â  if(v.startsWith('#')) return 'Â¡Mate a la vista! ğŸ';
Â  const n=Number(v);
Â  if(n>=1.5) return 'Â¡Ventaja grande! ğŸ˜„';
Â  if(n>=0.4) return 'Un poco mejor ğŸ™‚';
Â  if(n>-0.4) return 'Igualado ğŸ˜';
Â  if(n>-1.5) return 'Cuidadito ğŸ™';
Â  return 'PosiciÃ³n difÃ­cil ğŸ˜Ÿ';
}
// **CORRECCIÃ“N: Unificar la presentaciÃ³n de Eval**
function showEval(rawEval, depth, best){
Â  const evalDisplay = modeSel.value === 'kids' ? humanEval(rawEval) : rawEval;
Â  const box=document.getElementById('evalBox');
Â  // Usamos innerHTML para controlar mejor el texto y mantener el span #engineSrc
Â  box.innerHTML = `Eval: <b>${evalDisplay}</b> | Profundidad: ${depth} | Mejor jugada: ${best} <span id="engineSrc" class="note"></span>`;
}
function showPV(pv){
Â  const toks=pv.trim().split(/\s+/).slice(0,80);
Â  document.getElementById('pvBox').textContent=toks.map(uciToNice).join(' ')||'â€”';
}
let deb=null;
function scheduleAnalysis(){ clearTimeout(deb); deb=setTimeout(runAnalysis,500); }
function runAnalysis(){
Â  ensureEngine(); if(!engine) return;
Â  lastDepth=0; lastUi=0;
Â  const depth=Math.max(6,Math.min(30,+document.getElementById('maxDepth').value||18));
Â  const multi=Math.max(1,Math.min(3,+document.getElementById('multipv').value||1));
Â  const fen=frames[idx]||game.fen();

Â  // **CORRECCIÃ“N: Guardar el FEN que se estÃ¡ analizando**
Â  currentFen = fen;
Â  
Â  showEval('â€¦','â€”','â€”'); showPV('Pensandoâ€¦');
Â  engine.postMessage('stop');
Â  engine.postMessage('uci');
Â  engine.postMessage('setoption name MultiPV value '+multi);
Â  engine.postMessage('isready');
Â  engine.postMessage('ucinewgame');
Â  engine.postMessage('position fen '+fen);
Â  engine.postMessage('go depth '+depth);
}
document.getElementById('goBtn').onclick=runAnalysis;
document.getElementById('stopBtn').onclick=()=>{ if(engine) engine.postMessage('stop'); };

/* ====== Init ====== */
window.addEventListener('load', ()=>{ 
Â  frames=[game.fen()]; 
Â  idx=0; 
Â  resizeBoard(); // **CORRECCIÃ“N: Llamar al redimensionamiento al inicio**
Â  updateMoves(); 
Â  if(auto.checked) scheduleAnalysis();
});
// **CORRECCIÃ“N: Llamar al redimensionamiento al cambiar el tamaÃ±o de la ventana**
window.addEventListener('resize', resizeBoard);
</script>
