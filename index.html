<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Visor PGN ‚Äî interactivo + an√°lisis</title>

<!-- Reglas de ajedrez (estable) -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.12.0/chess.min.js"></script>

<style>
  :root{
    --bg:#0c1422; --panel:#0f1b2e; --borde:#232a36; --txt:#e6edf3; --muted:#9fb0c3;
    --sq-light:#e8f3e5; --sq-dark:#69a24a;
    --btn:#24324a; --btnbd:#3b4a63; --btnh:#2b3f5e; --ok:#22c55e;
    --arrow1:#28d06e; --arrow2:#4aa3ff;
    --sel:#ffd34db3; --dot:#00000066; --last:#ffe08a99;
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--txt);font:16px/1.4 Inter,system-ui,Segoe UI,Roboto,Arial}
  h1{max-width:1100px;margin:18px auto 6px;padding:0 16px;font-size:26px}
  .wrap{max-width:1100px;margin:0 auto;padding:12px 16px}
  .grid{display:grid;grid-template-columns:1fr 400px;gap:16px}
  @media (max-width:980px){.grid{grid-template-columns:1fr}}
  .panel{background:var(--panel);border:1px solid var(--borde);border-radius:14px;padding:12px}

  /* Tablero */
  #canvasBox{width:100%;max-width:720px;margin:auto}
  canvas{width:100%;height:auto;display:block;border:1px solid var(--borde);border-radius:10px;background:transparent}

  /* Controles */
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  button{background:var(--btn);border:1px solid var(--btnbd);color:var(--txt);border-radius:10px;padding:9px 13px;cursor:pointer}
  button:hover{background:var(--btnh)}
  .primary{background:#2f7d4e;border-color:#2f7d4e}
  .ghost{background:transparent;border-color:var(--borde)}
  .chip{padding:6px 10px;border-radius:8px;border:1px solid var(--borde);background:#0b1627;color:var(--txt)}
  input,select,textarea{font:inherit}
  input[type="number"]{width:92px;background:#0b1627;border:1px solid var(--borde);border-radius:8px;padding:8px;color:var(--txt)}
  textarea{width:100%;min-height:180px;background:#0b1627;border:1px solid var(--borde);border-radius:10px;padding:10px;color:var(--txt);resize:vertical;white-space:pre-wrap}
  .box{background:#0b1627;border:1px solid var(--borde);border-radius:10px;padding:10px}
  .mono{font-family:ui-monospace,Menlo,Consolas,monospace;white-space:pre-wrap}
  .note{color:var(--muted);font-size:14px}
  .status{margin-top:6px;color:var(--ok);font-size:14px}

  /* Barra profundidad */
  .bar{height:6px;border-radius:999px;background:#122034;overflow:hidden}
  .bar > i{display:block;height:100%;background:linear-gradient(90deg,#2dd4bf,#22c55e);width:0%}

  /* Input file ‚Äúbonito‚Äù */
  #file{display:none}
  label[for="file"]{display:inline-flex;align-items:center;gap:8px;cursor:pointer}
  label[for="file"]::before{content:"üìÇ"}

  /* Selector de partidas */
  #gamePicker{display:none;margin-top:6px}

  /* Modal promoci√≥n */
  #promo{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.45);z-index:40}
  #promo .card{background:#0f1b2e;border:1px solid var(--borde);padding:14px;border-radius:12px}
  #promo .card h3{margin:0 0 8px 0;font-size:16px}
  #promo .choices{display:flex;gap:8px}
  #promo button{font-size:24px;padding:8px 12px}
</style>
</head>
<body>
  <h1>Visor PGN ‚Äî interactivo + an√°lisis</h1>

  <div class="wrap grid">
    <!-- IZQUIERDA: tablero y mandos -->
    <div class="panel">
      <div id="canvasBox" aria-label="Tablero de ajedrez" role="img"><canvas id="board" width="720" height="720"></canvas></div>

      <div class="row" style="margin-top:10px">
        <button id="prevBtn" class="ghost" aria-label="Anterior (‚Üê)">‚Üê</button>
        <button id="playBtn" class="primary" aria-label="Play/Pausa (Espacio)">‚ñ∂</button>
        <button id="nextBtn" class="ghost" aria-label="Siguiente (‚Üí)">‚Üí</button>
        <button id="resetBtn" class="ghost" aria-label="Volver al inicio">Reiniciar</button>
        <button id="undoBtn" class="ghost" aria-label="Deshacer (U)">Undo</button>
        <button id="redoBtn" class="ghost" aria-label="Rehacer (R)">Redo</button>
        <button id="flipBtn" class="ghost" aria-label="Voltear tablero (F)">Flip</button>
        <label class="chip">Velocidad <input id="speed" type="number" value="800" min="100" step="50"></label>
        <label class="chip"><input id="auto" type="checkbox" checked> Auto-analizar</label>
      </div>

      <div id="status" class="status" role="status">OK: tablero listo. Arrastra o usa clic-clic.</div>
    </div>

    <!-- DERECHA: PGN + an√°lisis -->
    <div class="panel">
      <div class="row">
        <label for="file" class="primary" aria-label="Abrir PGN">Abrir PGN</label>
        <input id="file" type="file" accept=".pgn,.txt">
        <button id="copyFenBtn" class="ghost" aria-label="Copiar FEN">Copiar FEN</button>
      </div>

      <div id="gamePicker" class="row" aria-label="Selector de partida">
        <span class="note">Partidas en el archivo:</span>
        <select id="gameSelect" class="chip"></select>
        <span id="gameCount" class="note"></span>
      </div>

      <div class="note" style="margin:10px 0 4px">O pega PGN (opcional) y pulsa ‚ÄúImportar‚Äù:</div>
      <textarea id="pgnText" placeholder="Pega aqu√≠ tu PGN‚Ä¶"></textarea>
      <div class="row" style="margin-top:8px">
        <button id="loadTextBtn" class="primary" aria-label="Importar desde texto">Importar</button>
        <span id="gameInfo" class="note">Sin partida cargada.</span>
      </div>

      <div id="movesBox" class="box mono" style="margin-top:8px;min-height:56px" aria-live="polite">Movidas aparecer√°n aqu√≠‚Ä¶</div>

      <div class="row" style="margin-top:12px">
        <span class="note">An√°lisis Stockfish</span>
        <div class="bar" style="flex:1"><i id="depthBar" style="width:0%"></i></div>
      </div>

      <div class="row" style="gap:12px;margin-top:8px">
        <label class="chip">Profundidad m√°x: <input id="maxDepth" type="number" min="6" max="30" value="18"></label>
        <label class="chip">L√≠neas: <input id="multipv" type="number" min="1" max="2" value="2"></label>
        <button id="goBtn" class="primary" aria-label="Analizar posici√≥n">Analizar</button>
        <button id="stopBtn" class="ghost" aria-label="Detener an√°lisis">Detener</button>
      </div>

      <div id="evalBox" class="box" style="margin-top:8px">Eval: ‚Äî | Profundidad: ‚Äî | Mejor jugada: ‚Äî <span id="engineSrc" class="note"></span></div>
      <div id="pvBox" class="box mono" style="margin-top:8px">L√≠neas aparecer√°n aqu√≠‚Ä¶</div>
      <div id="errBox" class="note" style="margin-top:6px;color:#fca5a5"></div>
    </div>
  </div>

  <!-- Modal promoci√≥n -->
  <div id="promo">
    <div class="card" role="dialog" aria-modal="true" aria-label="Elegir pieza de promoci√≥n">
      <h3>Elige pieza de promoci√≥n</h3>
      <div class="choices">
        <button data-p="q" aria-label="Dama">‚ôï</button>
        <button data-p="r" aria-label="Torre">‚ôñ</button>
        <button data-p="b" aria-label="Alfil">‚ôó</button>
        <button data-p="n" aria-label="Caballo">‚ôò</button>
      </div>
    </div>
  </div>

<script>
/* =========================================================
   Estado principal (Chess.js) + representaci√≥n
   ========================================================= */
const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d', {alpha:true});
const SIZE = 720, S = SIZE/8;
const COLORS = { light:getCss('--sq-light'), dark:getCss('--sq-dark') };
const GLYPH = {'P':'‚ôô','N':'‚ôò','B':'‚ôó','R':'‚ôñ','Q':'‚ôï','K':'‚ôî','p':'‚ôü','n':'‚ôû','b':'‚ôù','r':'‚ôú','q':'‚ôõ','k':'‚ôö'};
const arrowColor1 = getCss('--arrow1'), arrowColor2 = getCss('--arrow2');

function getCss(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }

let game = new Chess();
let frames = [game.fen()], idx = 0;
let playing=false, timer=null;
let orientation = localStorage.getItem('orientation') || 'w'; // 'w' abajo por defecto
let selSquare=null, drag=null;
let lastMove=null, lastArrows=[]; // {from,to}

/* ================== Dibujo ================== */
function squareToRC(sq){
  const file = sq.charCodeAt(0)-97;
  const rank = parseInt(sq[1],10)-1; // 0..7 (a1=0)
  return {file, rank}; // file 0..7 (a..h), rank 0..7 (1..8)
}
function rcToCanvasXY(file, rank){
  // Tener en cuenta orientaci√≥n
  const c = orientation==='w' ? file : 7-file;
  const rBoard = orientation==='w' ? 7-rank : rank; // lienzo: 0 top
  return {x:c*S, y:rBoard*S};
}
function sqToCanvasXY(sq){ const {file,rank} = squareToRC(sq); return rcToCanvasXY(file,rank); }
function centerOfSquare(sq){ const p=sqToCanvasXY(sq); return {x:p.x+S/2, y:p.y+S/2}; }

function drawBoard(fenPieces, highlightSel=null, legalTargets=[]){
  // casillas
  for(let rr=0; rr<8; rr++){
    for(let cc=0; cc<8; cc++){
      // convertir rr/cc del canvas a file/rank l√≥gicos seg√∫n orientaci√≥n
      const file = orientation==='w' ? cc : 7-cc;
      const rankFromTop = rr;
      const rank = orientation==='w' ? 7-rankFromTop : rankFromTop;
      const light = (rank + file) % 2 === 0;
      ctx.fillStyle = light ? COLORS.light : COLORS.dark;
      ctx.fillRect(cc*S, rr*S, S, S);
    }
  }
  // √∫ltimo movimiento (sombreado)
  if(lastMove){
    ctx.fillStyle = getCss('--last');
    [lastMove.from, lastMove.to].forEach(s=>{
      const p = sqToCanvasXY(s);
      ctx.fillRect(p.x, p.y, S, S);
    });
  }
  // selecci√≥n
  if(highlightSel){
    const p = sqToCanvasXY(highlightSel);
    ctx.fillStyle = getCss('--sel');
    ctx.fillRect(p.x, p.y, S, S);
  }
  // destinos legales
  ctx.fillStyle = getCss('--dot');
  legalTargets.forEach(s=>{
    const p = centerOfSquare(s);
    ctx.beginPath(); ctx.arc(p.x, p.y, S*0.14, 0, Math.PI*2); ctx.fill();
  });

  // piezas
  const rows = fenPieces.split('/');
  ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.font = `${S*0.74}px "Segoe UI Symbol","Noto Color Emoji","Apple Color Emoji",serif`;

  for(let r=0;r<8;r++){
    let file=0;
    for(const ch of rows[r]){
      if(/\d/.test(ch)){ file += +ch; continue; }
      // pieza en (file, rankFromTop=r); convertir a rank l√≥gico:
      const rank = r; // r ya es de arriba a abajo (0..7)
      // mapa al canvas seg√∫n orientaci√≥n:
      const fileCanvas = orientation==='w' ? file : 7-file;
      const rankCanvas = orientation==='w' ? r : 7-r;
      const x=(fileCanvas+0.5)*S, y=(rankCanvas+0.5)*S;

      // si esta pieza corresponde a la que se est√° arrastrando, la dibujamos despu√©s
      if(drag && drag.from && sameSquareRC(file, 7-r, drag.from)) { file++; continue; }

      drawPieceGlyph(ch, x, y, (rank + file)%2===0);
      file++;
    }
  }

  // flechas (motor): mejor y segunda
  lastArrows.forEach((a,i)=> drawArrow(a.from, a.to, i===0? arrowColor1: arrowColor2));

  // pieza en arrastre
  if(drag){
    ctx.globalAlpha=0.95;
    ctx.lineWidth = S*0.06;
    ctx.strokeStyle='rgba(0,0,0,.85)';
    ctx.shadowColor='rgba(0,0,0,.35)'; ctx.shadowBlur=S*0.05;
    ctx.strokeText(GLYPH[drag.piece]||'', drag.x, drag.y);
    ctx.shadowBlur=0; ctx.fillStyle=/[PRNBQK]/.test(drag.piece)?'#ffffff':'#0b1120';
    ctx.fillText(GLYPH[drag.piece]||'', drag.x, drag.y);
    ctx.globalAlpha=1;
  }
}
function sameSquareRC(file, rank, fromSq){
  const rc = squareToRC(fromSq);
  return rc.file===file && rc.rank===rank;
}
function drawPieceGlyph(ch,cx,cy,onLight){
  // contorno claro/oscuro para contrastar
  ctx.lineWidth = S*0.06;
  ctx.strokeStyle = onLight ? 'rgba(0,0,0,.85)' : 'rgba(255,255,255,.9)';
  ctx.shadowColor = 'rgba(0,0,0,.35)'; ctx.shadowBlur = S*0.05;
  ctx.strokeText(GLYPH[ch]||'', cx, cy);
  ctx.shadowBlur = 0;
  ctx.fillStyle = /[PRNBQK]/.test(ch)? '#ffffff' : '#0b1120';
  ctx.fillText(GLYPH[ch]||'', cx, cy);
}
function drawArrow(from,to,color){
  const A = centerOfSquare(from), B = centerOfSquare(to);
  ctx.strokeStyle=color; ctx.lineWidth=10; ctx.lineCap='round';
  ctx.beginPath(); ctx.moveTo(A.x,A.y); ctx.lineTo(B.x,B.y); ctx.stroke();
  const ang=Math.atan2(B.y-A.y,B.x-A.x), L=18;
  ctx.beginPath(); ctx.moveTo(B.x,B.y);
  ctx.lineTo(B.x-L*Math.cos(ang-0.5),B.y-L*Math.sin(ang-0.5));
  ctx.moveTo(B.x,B.y);
  ctx.lineTo(B.x-L*Math.cos(ang+0.5),B.y-L*Math.sin(ang+0.5));
  ctx.stroke();
}
function render(){
  const fenPieces = (frames[idx]||game.fen()).split(' ')[0];
  const legal = selSquare ? legalTargetsFromFen(currentFen(), selSquare) : [];
  drawBoard(fenPieces, selSquare, legal);
  setStatus(`Posici√≥n ${idx}/${frames.length-1}`);
}
function setStatus(t){ document.getElementById('status').textContent=t; }
function currentFen(){ return frames[idx]||game.fen(); }

/* ================== Interacci√≥n (clic + arrastre) ================== */
function eventToBoard(ev){
  const rect = canvas.getBoundingClientRect();
  const px = (ev.touches? ev.touches[0].clientX: ev.clientX) - rect.left;
  const py = (ev.touches? ev.touches[0].clientY: ev.clientY) - rect.top;
  // columna/fila en canvas
  const col = Math.min(7, Math.max(0, Math.floor(px/rect.width*8)));
  const row = Math.min(7, Math.max(0, Math.floor(py/rect.width*8)));
  // transformar a file/rank l√≥gicos seg√∫n orientaci√≥n:
  const file = orientation==='w' ? col : 7-col;
  const rankFromTop = row;
  const rank = orientation==='w' ? 7-rankFromTop : rankFromTop;
  const sq = String.fromCharCode(97+file) + (rank+1);
  // coordenadas absolutas para dibujo del drag
  const xAbs = (col+0.5) * (SIZE/8);
  const yAbs = (row+0.5) * (SIZE/8);
  return {sq, xAbs, yAbs};
}

let rafId=null;
function requestRepaint(){ if(rafId) cancelAnimationFrame(rafId); rafId=requestAnimationFrame(()=>{ rafId=null; render(); }); }

canvas.addEventListener('mousedown', e=>{
  const {sq, xAbs, yAbs} = eventToBoard(e);
  const p = game.get(sq);
  if(p && p.color===sideToMove()){ // solo pieza del lado al turno (mejor UX)
    selSquare = sq;
    const glyph = p.color==='w'? p.type.toUpperCase() : p.type;
    drag = {from:sq, piece:glyph, x:xAbs, y:yAbs};
    requestRepaint();
  }else{
    selSquare = null;
    requestRepaint();
  }
});
canvas.addEventListener('mousemove', e=>{
  if(!drag) return;
  const {xAbs, yAbs} = eventToBoard(e);
  drag.x = xAbs; drag.y = yAbs;
  requestRepaint();
});
canvas.addEventListener('mouseup', e=>{
  if(!drag) return;
  const {sq} = eventToBoard(e);
  const from = drag.from; drag=null;
  finishMove(from, sq);
});
canvas.addEventListener('mouseleave', ()=>{ if(drag){ drag=null; requestRepaint(); }});
canvas.addEventListener('touchstart', e=>{ e.preventDefault(); canvas.dispatchEvent(new MouseEvent('mousedown',{clientX:e.touches[0].clientX, clientY:e.touches[0].clientY})); },{passive:false});
canvas.addEventListener('touchmove', e=>{ e.preventDefault(); canvas.dispatchEvent(new MouseEvent('mousemove',{clientX:e.touches[0].clientX, clientY:e.touches[0].clientY})); },{passive:false});
canvas.addEventListener('touchend', e=>{ e.preventDefault(); canvas.dispatchEvent(new MouseEvent('mouseup',{})); },{passive:false});

// clic-clic
canvas.addEventListener('click', e=>{
  if(drag) return; // ya gestionado en mouseup
  const {sq} = eventToBoard(e);
  if(selSquare && selSquare!==sq){ finishMove(selSquare, sq); selSquare=null; }
  else { const p = game.get(sq); selSquare = p && p.color===sideToMove() ? sq : null; requestRepaint(); }
});

function sideToMove(){ return (currentFen().split(' ')[1]||'w'); }
function legalTargetsFromFen(fen, sq){
  try{ const ch=new Chess(); ch.load(fen); return ch.moves({square:sq, verbose:true}).map(m=>m.to); }
  catch{ return []; }
}

/* ================== Promoci√≥n ================== */
const promo = document.getElementById('promo');
function needsPromotion(from,to){
  const p = game.get(from); if(!p || p.type!=='p') return false;
  return (p.color==='w' && to[1]==='8') || (p.color==='b' && to[1]==='1');
}
function finishMove(from,to){
  if(from===to) { requestRepaint(); return; }
  if(needsPromotion(from,to)){ openPromotion(piece=> performMove(from,to,piece)); }
  else performMove(from,to);
}
function performMove(from,to,promoPiece='q'){
  const mv = game.move({from,to,promotion:promoPiece});
  if(!mv){ setStatus('Movimiento ilegal'); requestRepaint(); return; }
  lastMove = {from: mv.from, to: mv.to};
  // cortar redoStack si exist√≠a
  redoStack.length=0;
  frames = frames.slice(0, idx+1);
  frames.push(game.fen());
  idx = frames.length-1;
  updateMovesSAN();
  lastArrows=[]; // limpiar flechas al mover manual
  requestRepaint();
  if(document.getElementById('auto').checked) scheduleAnalysis();
}
function openPromotion(cb){
  promo.style.display='flex';
  const handler = e=>{
    const p=e.target?.dataset?.p;
    if(!p) return;
    promo.style.display='none';
    promo.removeEventListener('click', handler);
    cb(p);
  };
  promo.addEventListener('click', handler);
}

/* ================== Undo/Redo ================== */
const redoStack = [];
document.getElementById('undoBtn').onclick = ()=>{
  if(idx===0) return;
  redoStack.push(frames[idx]); // guardar para rehacer
  idx--; game.load(frames[idx]); updateMovesSAN(); lastArrows=[]; requestRepaint();
  if(auto.checked) scheduleAnalysis();
};
document.getElementById('redoBtn').onclick = ()=>{
  if(!redoStack.length) return;
  const nextFen = redoStack.pop();
  frames.push(nextFen); idx=frames.length-1; game.load(nextFen); updateMovesSAN(); lastArrows=[]; requestRepaint();
  if(auto.checked) scheduleAnalysis();
};

/* ================== Navegaci√≥n / reproducci√≥n ================== */
document.getElementById('prevBtn').onclick = ()=>{ if(idx>0){ idx--; game.load(frames[idx]); lastArrows=[]; requestRepaint(); if(auto.checked) scheduleAnalysis(); } };
document.getElementById('nextBtn').onclick = ()=>{ if(idx<frames.length-1){ idx++; game.load(frames[idx]); lastArrows=[]; requestRepaint(); if(auto.checked) scheduleAnalysis(); } };
document.getElementById('resetBtn').onclick = ()=>{ idx=0; game.load(frames[0]); lastArrows=[]; requestRepaint(); if(auto.checked) scheduleAnalysis(); };

document.getElementById('playBtn').onclick = ()=>{
  if(playing){ clearInterval(timer); playing=false; playBtn.textContent='‚ñ∂'; return; }
  playing=true; playBtn.textContent='‚è∏';
  const ms=Math.max(100, +document.getElementById('speed').value||800);
  timer=setInterval(()=>{ if(idx<frames.length-1){ idx++; game.load(frames[idx]); lastArrows=[]; requestRepaint(); if(auto.checked) scheduleAnalysis(); } else { clearInterval(timer); playing=false; playBtn.textContent='‚ñ∂'; } }, ms);
};

document.getElementById('flipBtn').onclick = ()=>{
  orientation = (orientation==='w'?'b':'w');
  localStorage.setItem('orientation', orientation);
  requestRepaint();
};

/* ================== Atajos de teclado ================== */
window.addEventListener('keydown', (e)=>{
  if(e.target && (/INPUT|TEXTAREA|SELECT/).test(e.target.tagName)) return;
  if(e.key==='ArrowLeft'){ prevBtn.click(); }
  else if(e.key==='ArrowRight'){ nextBtn.click(); }
  else if(e.key===' '){ e.preventDefault(); playBtn.click(); }
  else if(e.key==='a' || e.key==='A'){ goBtn.click(); }
  else if(e.key==='f' || e.key==='F'){ flipBtn.click(); }
  else if(e.key==='u' || e.key==='U'){ undoBtn.click(); }
  else if(e.key==='r' || e.key==='R'){ redoBtn.click(); }
});

/* ================== Lista de jugadas ================== */
function updateMovesSAN(){
  const san = game.history();
  document.getElementById('movesBox').textContent =
    san.map((m,i)=>(i%2===0? (Math.floor(i/2)+1)+'. ':'')+m).join(' ');
  document.getElementById('gameInfo').textContent = `Movidas: ${san.length}`;
}

/* =========================================================
   Importaci√≥n PGN: robusta (UTF-8/latin-1, variantes anidadas,
   NAGs, comentarios, m√∫ltiples partidas)
   ========================================================= */
const errBox = document.getElementById('errBox');

document.getElementById('file').onchange = async ()=>{
  const f = file.files?.[0]; if(!f) return;
  try{
    const buf = await f.arrayBuffer();
    let txt = tryDecode(buf, 'utf-8');
    if(countReplacementChars(txt)>5){ txt = tryDecode(buf, 'windows-1252'); }
    importPGNCollection(txt);
  }catch(e){ showErr('Error leyendo archivo PGN.'); }
};
document.getElementById('loadTextBtn').onclick = ()=> importPGNCollection(document.getElementById('pgnText').value);

function tryDecode(buf, enc){
  try{ return new TextDecoder(enc, {fatal:false}).decode(buf); }
  catch{ return new TextDecoder('utf-8',{fatal:false}).decode(buf); }
}
function countReplacementChars(s){ return (s.match(/\uFFFD/g)||[]).length; }

function cleanPGNBase(txt){
  return txt
    .replace(/^\uFEFF/, '')       // BOM
    .replace(/\r\n?/g, '\n')      // saltos
    .replace(/\$\d+/g,'')         // NAGs
    .replace(/\{[^}]*\}/g,'')     // comentarios {...}
    .trim();
}
function removeNestedVariants(txt){
  // Elimina variantes (...) de forma anidada
  let prev;
  do{
    prev = txt;
    txt = txt.replace(/\([^()]*\)/g,' ');
  }while(txt.indexOf('(')!==-1 && txt!==prev);
  return txt;
}
function splitGames(raw){
  const txt = removeNestedVariants(cleanPGNBase(raw)).replace(/\n{3,}/g,'\n\n');
  // cortar por headers [Event "..."] preservando el primero al inicio del archivo tambi√©n
  const parts = txt.split(/\n(?=\[Event\s*")|^(?=\[Event\s*")/gm).filter(Boolean).map(s=>s.trim());
  if(parts.length<=1) return [txt.trim()];
  return parts;
}
function gameTitle(pgn){
  const ev = (pgn.match(/\[Event\s*"([^"]*)"\]/)||[])[1]||'Partida';
  const d  = (pgn.match(/\[Date\s*"([^"]*)"\]/)||[])[1]||'';
  const w  = (pgn.match(/\[White\s*"([^"]*)"\]/)||[])[1]||'';
  const b  = (pgn.match(/\[Black\s*"([^"]*)"\]/)||[])[1]||'';
  return `${ev} ‚Äî ${w} vs ${b}${d? ' ('+d+')' : ''}`;
}
function showErr(msg, snippet){
  errBox.textContent = snippet ? `${msg} ¬∑ Ejemplo: ${snippet}` : msg;
}
function importPGNCollection(raw){
  errBox.textContent='';
  const games = splitGames(raw);
  if(!games.length){ showErr('No se encontraron partidas en el archivo.'); return; }
  // Preparar selector si hay varias
  const sel = document.getElementById('gameSelect');
  sel.innerHTML='';
  games.forEach((g,i)=>{ const o=document.createElement('option'); o.value=i; o.textContent=gameTitle(g); sel.appendChild(o); });
  document.getElementById('gameCount').textContent = games.length>1 ? `(${games.length})` : '';
  document.getElementById('gamePicker').style.display = games.length>1 ? 'flex' : 'none';
  sel.onchange = ()=> loadPGN(games[+sel.value], true);
  // Cargar la primera autom√°ticamente
  loadPGN(games[0], true);
}
function loadPGN(pgn, resetStatus){
  const cleaned = pgn; // ya se limpi√≥ arriba
  const ok = game.load_pgn(cleaned, {sloppy:true});
  if(!ok){
    // Muestra un peque√±o extracto de la zona de movidas
    const mvTxt = (cleaned.match(/\n\n([\s\S]+)/)||[])[1]||cleaned;
    showErr('PGN inv√°lido', mvTxt.slice(0,200)+'‚Ä¶');
    return false;
  }
  // reconstruir frames fielmente
  const san = game.history();
  game.reset(); frames=[game.fen()];
  lastMove=null; lastArrows=[];
  for(const mv of san){ const m=game.move(mv); frames.push(game.fen()); lastMove={from:m.from,to:m.to}; }
  idx=frames.length-1; updateMovesSAN(); requestRepaint();
  if(document.getElementById('auto').checked) scheduleAnalysis();
  if(resetStatus) setStatus('Partida cargada.');
  return true;
}

document.getElementById('copyFenBtn').onclick = async ()=>{
  const fen = currentFen(); await navigator.clipboard.writeText(fen); setStatus('FEN copiado.');
};

/* =========================================================
   Stockfish (Web Worker) con debounce y flechas PV
   ========================================================= */
let engine=null, engineReady=false, lastDepth=0, lastBest='';
let debTimer=null;

const MIRROR_JS = 'https://cdnjs.cloudflare.com/ajax/libs/stockfish.js/9.0.0/stockfish.js';

function ensureEngine(){
  if(engine) return engine;
  const boot = `
    self.onerror = e => postMessage({type:'sf-error', msg:String(e && e.message || e)});
    try { importScripts('${MIRROR_JS}'); postMessage({type:'sf-ok'}); }
    catch(e){ postMessage({type:'sf-error', msg:'No se pudo cargar Stockfish'}); }
  `;
  engine = new Worker(URL.createObjectURL(new Blob([boot],{type:'application/javascript'})));
  engine.onmessage = onEngineMessage;
  return engine;
}
function onEngineMessage(e){
  const d = e.data;
  if(d?.type==='sf-ok'){ engineReady=true; document.getElementById('engineSrc').textContent=' (motor listo)'; return; }
  if(d?.type==='sf-error'){ showEval('‚Äî','‚Äî','‚Äî'); document.getElementById('engineSrc').textContent=' (motor: error)'; return; }
  const line = (typeof d==='string') ? d : (d?.data||'');
  if(!line || !line.startsWith('info ')) return;

  // Parseo UCI info
  const depth = +(line.match(/\bdepth\s+(\d+)/)||[])[1] || lastDepth;
  const multipv = +(line.match(/\bmultipv\s+(\d+)/)||[])[1] || 1;
  const cp  = (line.match(/\bcp\s+(-?\d+)/)||[])[1];
  const mate= (line.match(/\bmate\s+(-?\d+)/)||[])[1];
  const pv  = (line.match(/\bpv\s+(.+)/)||[])[1] || '';

  // actualizar s√≥lo si hay progreso real
  if(depth<lastDepth) return;
  lastDepth = depth;

  const score = mate ? ('#'+mate) : (cp? (Number(cp)/100).toFixed(2) : '‚Äî');
  const bestMove = pv.split(' ')[0]||'‚Äî';
  if(bestMove!==lastBest) lastBest=bestMove;

  // Guardar PVs por √≠ndice y redibujar flechas
  if(!latest) latest={depth:0, pv:{}};
  latest.depth = Math.max(latest.depth||0, depth);
  latest.pv[multipv] = pv;

  refreshEngineUI(score);
}
let latest = {depth:0, pv:{}};

function refreshEngineUI(scoreText){
  // Barra de profundidad
  const dMax = Math.max(6, Math.min(30, +document.getElementById('maxDepth').value||18));
  document.getElementById('depthBar').style.width = `${Math.min(100, Math.round((latest.depth||0)/dMax*100))}%`;

  // Eval y PV (figuras)
  const pv1 = latest.pv[1]||'', pv2 = latest.pv[2]||'';
  showEval(scoreText, latest.depth||'‚Äî', uciToNice((pv1.split(' ')[0]||'‚Äî')));
  showPV([pv1,pv2].filter(Boolean).map((pv,i)=> (i? '‚ë° ':'‚ë† ') + pvToNice(pv)).join('\n'));

  // Flechas en el tablero
  lastArrows = [];
  if(pv1){ const m1 = firstUciMove(pv1); if(m1) lastArrows.push(m1); }
  if(pv2){ const m2 = firstUciMove(pv2); if(m2) lastArrows.push(m2); }
  requestRepaint();
}
function uciToNice(uci){
  if(!uci || uci==='‚Äî') return '‚Äî';
  const from=uci.slice(0,2), to=uci.slice(2,4), promo=uci[4];
  const piece=game.get(from);
  const fig = piece ? ({p:'',n:'‚ôò',b:'‚ôó',r:'‚ôñ',q:'‚ôï',k:'‚ôî'}[piece.type]||'') : '';
  const promoFig = promo ? '='+({q:'‚ôï',r:'‚ôñ',b:'‚ôó',n:'‚ôò'}[promo]||promo.toUpperCase()) : '';
  return fig+from+'‚Äì'+to+promoFig;
}
function pvToNice(pv){
  return pv.trim().split(/\s+/).slice(0,80).map(uciToNice).join(' ');
}
function firstUciMove(pv){
  const t = pv.trim().split(/\s+/)[0]||'';
  if(t.length<4) return null;
  return {from:t.slice(0,2), to:t.slice(2,4)};
}
function showEval(ev,depth,best){
  const box=document.getElementById('evalBox');
  box.textContent = `Eval: ${ev} | Profundidad: ${depth} | Mejor jugada: ${best} `;
  const src=document.createElement('span'); src.id='engineSrc'; src.className='note';
  box.appendChild(src);
}
function showPV(text){ document.getElementById('pvBox').textContent = text || '‚Äî'; }

function scheduleAnalysis(){ clearTimeout(debTimer); debTimer=setTimeout(runAnalysis, 800); }
function runAnalysis(){
  ensureEngine(); if(!engine) return;
  lastDepth=0; lastBest=''; latest={depth:0,pv:{}};
  const depth = Math.max(6, Math.min(30, +document.getElementById('maxDepth').value||18));
  const multi = Math.max(1, Math.min(2, +document.getElementById('multipv').value||2));
  const fen   = currentFen();
  showEval('‚Ä¶','‚Äî','‚Äî'); showPV('Pensando‚Ä¶');
  engine.postMessage('uci');
  engine.postMessage('setoption name MultiPV value '+multi);
  engine.postMessage('isready');
  engine.postMessage('ucinewgame');
  engine.postMessage('position fen '+fen);
  engine.postMessage('go depth '+depth);
}
document.getElementById('goBtn').onclick = runAnalysis;
document.getElementById('stopBtn').onclick = ()=>{ if(engine) engine.postMessage('stop'); };

/* =========================================================
   Inicio
   ========================================================= */
function initialRender(){
  frames=[game.fen()]; idx=0; lastMove=null; lastArrows=[];
  requestRepaint(); updateMovesSAN();
}
window.addEventListener('load', initialRender);

/* Utilidad CSS var */
function getComputedVar(name){ return getComputedStyle(document.documentElement).getPropertyValue(name); }
</script>
</body>
</html>
