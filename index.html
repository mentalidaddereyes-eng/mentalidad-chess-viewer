<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Visor PGN — tablero interactivo + análisis</title>

<!-- Reglas PGN/movimiento -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.12.0/chess.min.js"></script>

<style>
  :root{
    /* colores base */
    --bg:#0c1422; --panel:#0f1b2e; --borde:#232a36; --txt:#e6edf3; --muted:#9fb0c3;
    /* tablero verde / blanco */
    --sq-light:#e8f3e5;
    --sq-dark:#69a24a;
    /* botones */
    --btn:#24324a; --btnbd:#3b4a63; --btnh:#2b3f5e; --ok:#22c55e; --warn:#d97706;
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--txt);font:16px/1.4 Inter,system-ui,Segoe UI,Roboto,Arial}
  h1{max-width:1100px;margin:18px auto 6px;padding:0 16px;font-size:26px}
  .wrap{max-width:1100px;margin:0 auto;padding:12px 16px}
  .grid{display:grid;grid-template-columns:1fr 380px;gap:14px}
  @media (max-width:980px){.grid{grid-template-columns:1fr}}
  .panel{background:var(--panel);border:1px solid var(--borde);border-radius:14px;padding:12px}

  /* tablero canvas */
  #canvasBox{width:100%;max-width:720px;margin:auto}
  canvas{width:100%;height:auto;display:block;border:1px solid var(--borde);border-radius:10px;background:transparent}
  .status{margin-top:6px;color:var(--ok);font-size:14px}

  /* controles compactos */
  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  button{background:var(--btn);border:1px solid var(--btnbd);color:var(--txt);border-radius:10px;padding:9px 13px;cursor:pointer}
  button:hover{background:var(--btnh)}
  .primary{background:#2f7d4e;border-color:#2f7d4e}
  .ghost{background:transparent;border-color:var(--borde)}
  .chip{padding:6px 10px;border-radius:8px;border:1px solid var(--borde);background:#0b1627}
  input,select,textarea{font:inherit}
  input[type="number"]{width:92px;background:#0b1627;border:1px solid var(--borde);border-radius:8px;padding:8px;color:var(--txt)}
  textarea{width:100%;min-height:200px;background:#0b1627;border:1px solid var(--borde);border-radius:10px;padding:10px;color:var(--txt);resize:vertical;white-space:pre-wrap}
  .box{background:#0b1627;border:1px solid var(--borde);border-radius:10px;padding:10px}
  .mono{font-family:ui-monospace,Menlo,Consolas,monospace;white-space:pre-wrap}
  .note{color:var(--muted);font-size:14px}
  .muted{color:var(--muted)}
  .badge{display:inline-block;padding:2px 8px;border-radius:999px;background:rgba(255,255,255,.06);border:1px solid var(--borde);font-size:12px}
  .bar{height:6px;border-radius:999px;background:#122034;overflow:hidden}
  .bar > i{display:block;height:100%;background:linear-gradient(90deg,#2dd4bf,#22c55e);width:0%}
</style>
</head>
<body>
  <h1>Visor PGN — tablero interactivo + análisis</h1>

  <div class="wrap grid">
    <!-- IZQUIERDA: tablero + controles -->
    <div class="panel">
      <div id="canvasBox"><canvas id="board" width="720" height="720"></canvas></div>

      <div class="row" style="margin-top:10px">
        <button id="prevBtn" class="ghost">← Anterior</button>
        <button id="playBtn" class="primary">▶ Play</button>
        <button id="nextBtn" class="ghost">Siguiente →</button>
        <button id="resetBtn" class="ghost">Reiniciar</button>
        <label class="chip">Velocidad <input id="speed" type="number" value="800" min="100" step="50"></label>
        <label class="chip"><input id="auto" type="checkbox" checked> Auto-analizar</label>
      </div>

      <div id="status" class="status">OK: tablero listo. Click o arrastra una pieza para mover.</div>
    </div>

    <!-- DERECHA: PGN + análisis -->
    <div class="panel">
      <div class="row">
        <input id="file" type="file" accept=".pgn,.txt">
        <button id="loadFileBtn" class="primary">Cargar PGN</button>
        <button id="copyFenBtn" class="ghost">Copiar FEN</button>
      </div>

      <div class="note" style="margin:8px 0 4px">Pega aquí un PGN (o usa “Cargar PGN”):</div>
      <textarea id="pgnText" placeholder="Pega tu PGN aquí…"></textarea>

      <div class="row" style="margin-top:8px">
        <button id="loadTextBtn" class="primary">Cargar desde texto</button>
        <span id="gameInfo" class="note">Sin partida cargada.</span>
      </div>

      <div id="movesBox" class="box mono" style="margin-top:8px;min-height:56px">Movidas aparecerán aquí…</div>

      <div class="row" style="margin-top:12px">
        <span class="badge">Análisis Stockfish</span>
        <div class="bar" style="flex:1"><i id="depthBar" style="width:0%"></i></div>
      </div>

      <div class="row" style="gap:12px;margin-top:8px">
        <label class="chip">Profundidad máx: <input id="maxDepth" type="number" min="6" max="30" value="18"></label>
        <label class="chip">Líneas: <input id="multipv" type="number" min="1" max="3" value="1"></label>
        <button id="goBtn" class="primary">Analizar posición</button>
        <button id="stopBtn" class="ghost">Detener</button>
      </div>

      <div id="evalBox" class="box" style="margin-top:8px">Eval: — | Profundidad: — | Mejor jugada: — <span id="engineSrc" class="muted"></span></div>
      <div id="pvBox" class="box mono" style="margin-top:8px">Líneas aparecerán aquí…</div>
    </div>
  </div>

<script>
/* =========================================================
   Tablero interactivo Canvas + lógica (Chess.js)
   ========================================================= */
const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d', {alpha:true});
const SIZE = 720, S = SIZE/8;
const COLORS = { light:getCss('--sq-light'), dark:getCss('--sq-dark') };
const GLYPH = {'P':'♙','N':'♘','B':'♗','R':'♖','Q':'♕','K':'♔','p':'♟','n':'♞','b':'♝','r':'♜','q':'♛','k':'♚'};
function getCss(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }

let game = new Chess();
let frames = [game.fen()], idx = 0;
let playing = false, timer = null;
let selSquare = null;         // para clic-clic
let drag = null;              // para arrastrar {from, piece, x, y}

/* --- dibujo del tablero con piezas con contorno + sombra --- */
function drawBoard(fenPieces, highlightSquare=null){
  // casillas
  for(let r=0;r<8;r++){
    for(let c=0;c<8;c++){
      const light = (r+c)%2===0;
      ctx.fillStyle = light? COLORS.light : COLORS.dark;
      ctx.fillRect(c*S, r*S, S, S);
      if(highlightSquare && highlightSquare.r===r && highlightSquare.c===c){
        ctx.fillStyle = 'rgba(255,255,0,.18)';
        ctx.fillRect(c*S, r*S, S, S);
      }
    }
  }
  // piezas
  const rows = fenPieces.split('/');
  ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.font = `${S*0.74}px "Segoe UI Symbol","Noto Color Emoji","Apple Color Emoji",serif`;
  for(let r=0;r<8;r++){
    let file=0;
    for(const ch of rows[r]){
      if(/\d/.test(ch)){ file += parseInt(ch,10); }
      else{
        const x=(file+0.5)*S, y=(r+0.5)*S;
        const lightSquare = (r+file)%2===0;
        // contorno y sombra para máxima legibilidad
        ctx.lineWidth = S*0.06;
        ctx.strokeStyle = lightSquare? 'rgba(0,0,0,.8)' : 'rgba(255,255,255,.9)';
        ctx.shadowColor = 'rgba(0,0,0,.35)';
        ctx.shadowBlur = S*0.05;
        ctx.strokeText(GLYPH[ch]||'', x, y);
        ctx.shadowBlur = 0;
        ctx.fillStyle = /[PRNBQK]/.test(ch)? '#f8fafc' : '#0b1120';
        ctx.fillText(GLYPH[ch]||'', x, y);
        file++;
      }
    }
  }
  // pieza en arrastre
  if(drag){
    const {piece,x,y} = drag;
    ctx.lineWidth = S*0.06;
    ctx.strokeStyle = 'rgba(0,0,0,.85)';
    ctx.shadowColor = 'rgba(0,0,0,.35)'; ctx.shadowBlur = S*0.05;
    ctx.strokeText(GLYPH[piece]||'', x, y);
    ctx.shadowBlur = 0; ctx.fillStyle = /[PRNBQK]/.test(piece)? '#ffffff' : '#0b1120';
    ctx.fillText(GLYPH[piece]||'', x, y);
  }
}
function render(){
  const fen = (frames[idx]||game.fen()).split(' ')[0];
  drawBoard(fen);
  setStatus(`Posición ${idx}/${frames.length-1}`);
}
/* helpers */
function algebraicToRC(sq){ return {c: sq.charCodeAt(0)-97, r: 8-parseInt(sq[1],10)} }
function rcToAlgebraic(r,c){ return String.fromCharCode(97+c)+(8-r) }
function eventToSquare(ev){
  const rect = canvas.getBoundingClientRect();
  const x = (ev.touches?ev.touches[0].clientX:ev.clientX)-rect.left;
  const y = (ev.touches?ev.touches[0].clientY:ev.clientY)-rect.top;
  const c = Math.min(7, Math.max(0, Math.floor(x/rect.width*8)));
  const r = Math.min(7, Math.max(0, Math.floor(y/rect.width*8)));
  return {r,c, x:x/rect.width*SIZE, y:y/rect.width*SIZE};
}
function setStatus(t){ document.getElementById('status').textContent = t; }

/* --- interacción: clic-clic y arrastrar/soltar --- */
canvas.addEventListener('mousedown', e=>{
  const q = eventToSquare(e); const sq = rcToAlgebraic(q.r,q.c);
  const piece = game.get(sq);
  if(piece){
    selSquare = sq;
    drag = {from:sq, piece:(piece.color==='w'?piece.type.toUpperCase():piece.type), x:q.x, y:q.y};
    drawBoard(game.fen().split(' ')[0], {r:q.r,c:q.c});
  }else{
    selSquare = null;
  }
});
canvas.addEventListener('mousemove', e=>{
  if(!drag) return;
  const q = eventToSquare(e);
  drag.x = q.x; drag.y = q.y;
  drawBoard(game.fen().split(' ')[0]);
});
canvas.addEventListener('mouseup', e=>{
  if(!drag) return endDrag(e);
  endDrag(e);
});
canvas.addEventListener('mouseleave', ()=>{ if(drag){ drag=null; render(); }});
canvas.addEventListener('touchstart', e=>{ e.preventDefault(); canvas.dispatchEvent(new MouseEvent('mousedown',{clientX:e.touches[0].clientX, clientY:e.touches[0].clientY})); },{passive:false});
canvas.addEventListener('touchmove', e=>{ e.preventDefault(); canvas.dispatchEvent(new MouseEvent('mousemove',{clientX:e.touches[0].clientX, clientY:e.touches[0].clientY})); },{passive:false});
canvas.addEventListener('touchend', e=>{ e.preventDefault(); canvas.dispatchEvent(new MouseEvent('mouseup',{})); },{passive:false});

function endDrag(e){
  const q = eventToSquare(e); const to = rcToAlgebraic(q.r,q.c);
  const from = drag.from; drag=null;
  tryMove(from,to);
}
canvas.addEventListener('click', e=>{
  // clic-clic (si no hubo drag)
  if(drag) return;
  const q = eventToSquare(e); const sq = rcToAlgebraic(q.r,q.c);
  if(selSquare && selSquare!==sq){ tryMove(selSquare, sq); selSquare=null; }
  else { const piece = game.get(sq); selSquare = piece? sq : null; }
});

function tryMove(from,to){
  const mv = game.move({from,to,promotion:'q'});
  if(!mv){ setStatus('Movimiento ilegal'); render(); return; }
  frames.push(game.fen()); idx = frames.length-1; render();
  updateMovesSAN();
  if(document.getElementById('auto').checked) scheduleAnalysis();
}

/* --- controles reproducción --- */
function updateMovesSAN(){
  const san = game.history();
  document.getElementById('movesBox').textContent =
    san.map((m,i)=>(i%2===0? (Math.floor(i/2)+1)+'. ':'')+m).join(' ');
  document.getElementById('gameInfo').textContent = `Movidas: ${san.length}`;
}
document.getElementById('prevBtn').onclick = ()=>{ if(idx>0){ idx--; game.load(frames[idx]); render(); if(document.getElementById('auto').checked) scheduleAnalysis(); }};
document.getElementById('nextBtn').onclick = ()=>{ if(idx<frames.length-1){ idx++; game.load(frames[idx]); render(); if(document.getElementById('auto').checked) scheduleAnalysis(); }};
document.getElementById('resetBtn').onclick = ()=>{ idx=0; game.load(frames[0]); render(); if(document.getElementById('auto').checked) scheduleAnalysis(); };
document.getElementById('playBtn').onclick = ()=>{
  if(playing){ clearInterval(timer); playing=false; document.getElementById('playBtn').textContent='▶ Play'; return; }
  playing = true; document.getElementById('playBtn').textContent='⏸ Pausa';
  const ms = Math.max(100, +document.getElementById('speed').value||800);
  timer = setInterval(()=>{ if(idx<frames.length-1){ idx++; game.load(frames[idx]); render(); if(document.getElementById('auto').checked) scheduleAnalysis(); } else { clearInterval(timer); playing=false; document.getElementById('playBtn').textContent='▶ Play'; }}, ms);
};

/* --- cargar PGN (archivo / texto) robusto --- */
function cleanPGN(txt){
  return txt
   .replace(/^\uFEFF/, '')         // BOM
   .replace(/\r\n?/g, '\n')        // saltos
   .replace(/\n{3,}/g, '\n\n')     // múltiples líneas en blanco
   .replace(/\{[^}]*\}/g, '')      // comentarios {...}
   .trim();
}
function loadPGN(pgnRaw){
  const pgn = cleanPGN(pgnRaw);
  const ok = game.load_pgn(pgn, {sloppy:true});
  if(!ok){ alert('PGN inválido.'); return false; }
  const san = game.history();
  // reconstruir frames
  game.reset(); frames=[game.fen()]; for(const mv of san){ game.move(mv); frames.push(game.fen()); }
  idx=0; render(); updateMovesSAN(); return true;
}
document.getElementById('loadFileBtn').onclick = async ()=>{
  const f = document.getElementById('file').files?.[0];
  if(!f){ alert('Elige un archivo .pgn'); return; }
  const txt = await f.text();
  if(loadPGN(txt) && document.getElementById('auto').checked) scheduleAnalysis();
};
document.getElementById('loadTextBtn').onclick = ()=>{
  const ok = loadPGN(document.getElementById('pgnText').value);
  if(ok && document.getElementById('auto').checked) scheduleAnalysis();
};
document.getElementById('copyFenBtn').onclick = async ()=>{
  const fen = frames[idx] || game.fen();
  await navigator.clipboard.writeText(fen);
  setStatus('FEN copiado al portapapeles.');
};

/* =========================================================
   Stockfish (Web Worker) + UI “calmada”
   ========================================================= */
let engine=null, engineReady=false, lastDepth=0, lastBest='';
const MIRRORS = [
  'https://cdnjs.cloudflare.com/ajax/libs/stockfish.js/9.0.0/stockfish.min.js',
  'https://cdnjs.cloudflare.com/ajax/libs/stockfish.js/9.0.0/stockfish.js'
];
function ensureEngine(){
  if(engine) return engine;
  const code = `
    self.onerror = function(e){ postMessage({type:'sf-error', msg:String(e && e.message || e)}) };
    (function load(i){
      if(i>=${MIRRORS.length}){ postMessage({type:'sf-error', msg:'No se pudo cargar Stockfish (mirrors fallidos).'}); return; }
      try { importScripts('${MIRRORS[0]}'); postMessage({type:'sf-ok', src:'CDNJS'}); }
      catch(e){ try{ importScripts('${MIRRORS[1]}'); postMessage({type:'sf-ok', src:'CDNJS fallback'}); } catch(err){ postMessage({type:'sf-retry', i:i+1}); } }
    })(0);
  `;
  const blob = new Blob([code], {type:'application/javascript'});
  const url = URL.createObjectURL(blob);
  engine = new Worker(url);
  engine.onmessage = onEngineMessage;
  return engine;
}
function onEngineMessage(e){
  const d = e.data;
  if(d?.type==='sf-retry'){ return; }
  if(d?.type==='sf-error'){ showEval('—','—','—'); document.getElementById('engineSrc').textContent = ' (motor: error)'; return; }
  if(d?.type==='sf-ok'){ engineReady=true; document.getElementById('engineSrc').textContent = ` (motor: ${d.src})`; return; }

  const line = (typeof d==='string') ? d : (d?.data||'');
  if(!line) return;

  if(line.startsWith('info ')){
    const depth = +(line.match(/\bdepth\s+(\d+)/)||[])[1] || lastDepth;
    const cp    = (line.match(/\bcp\s+(-?\d+)/)||[])[1];
    const mate  = (line.match(/\bmate\s+(-?\d+)/)||[])[1];
    const pv    = (line.match(/\bpv\s+(.+)/)||[])[1] || '';
    // sólo refrescar si hay progreso real
    if(depth<lastDepth) return;
    lastDepth = depth;
    const evalTxt = mate ? ('#'+mate) : (cp? (Number(cp)/100).toFixed(2) : '—');
    const bestMove = pv.split(' ')[0]||'—';
    if(bestMove!==lastBest){ lastBest = bestMove; }
    showEval(evalTxt, depth, bestMove);
    showPV(pv);
    // barra de progreso suavizada
    const dBar = Math.min(30, Math.max(6, +document.getElementById('maxDepth').value||18));
    document.getElementById('depthBar').style.width = `${Math.min(100, Math.round(depth/dBar*100))}%`;
  }
}

function showEval(evalTxt, depth, best){
  document.getElementById('evalBox').textContent = `Eval: ${evalTxt} | Profundidad: ${depth} | Mejor jugada: ${uciToNice(best)}`;
  const src = document.createElement('span'); src.id='engineSrc'; src.className='muted';
  document.getElementById('evalBox').append(' '); document.getElementById('evalBox').appendChild(src);
}
function showPV(pv){
  // convertir UCI a figuritas con espaciado
  const tokens = pv.trim().split(/\s+/).slice(0, 80);
  const pretty = tokens.map(uciToNice).join(' ');
  document.getElementById('pvBox').textContent = pretty || '—';
}
function uciToNice(uci){
  if(!uci || uci==='—') return '—';
  // e2e4, g8f6, e7e8q...
  const pieceGuess = game.get(uci.slice(0,2));
  const figurine = pieceGuess ? ({p:'',n:'♘',b:'♗',r:'♖',q:'♕',k:'♔'}[pieceGuess.type]||'') : '';
  const promo = uci.length>4 ? '='+({'q':'♕','r':'♖','b':'♗','n':'♘'}[uci[4]]||uci[4].toUpperCase()) : '';
  return figurine + uci.slice(0,2) + '–' + uci.slice(2,4) + promo;
}

/* lanzar análisis (debounced) */
let debTimer=null;
function scheduleAnalysis(){
  clearTimeout(debTimer);
  debTimer = setTimeout(runAnalysis, 500);
}
function runAnalysis(){
  ensureEngine();
  if(!engine){ return; }
  lastDepth=0; lastBest='';
  const depth = Math.max(6, Math.min(30, +document.getElementById('maxDepth').value||18));
  const multi = Math.max(1, Math.min(3, +document.getElementById('multipv').value||1));
  const fen   = frames[idx] || game.fen();

  showEval('…','—','—'); showPV('Pensando…');
  engine.postMessage('uci');
  engine.postMessage('setoption name MultiPV value '+multi);
  engine.postMessage('isready');
  engine.postMessage('ucinewgame');
  engine.postMessage('position fen '+fen);
  engine.postMessage('go depth '+depth);
}
document.getElementById('goBtn').onclick = runAnalysis;
document.getElementById('stopBtn').onclick = ()=>{ if(engine) engine.postMessage('stop'); };

/* init */
window.addEventListener('load', ()=>{
  frames=[game.fen()]; idx=0; render(); updateMovesSAN();
});
</script>
</body>
</html>
<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Visor PGN — interactivo + análisis</title>

<style>
  :root{
    --bg:#0b1220; --panel:#0f1b2e; --borde:#232a36; --txt:#e6edf3; --muted:#a7b6c9;
    --sq-a:#e8f1e6; --sq-b:#6fb363;
    --sel:#ffcc00aa; --dot:#00000066; --last:#ffe08a99;
    --btn:#223149; --btnbd:#364760; --btnh:#2e4970; --ok:#22c55e;
    --arrow1:#28d06e; --arrow2:#4aa3ff;
  }
  *{box-sizing:border-box}
  body{margin:0;background:var(--bg);color:var(--txt);font-family:Inter,system-ui,Segoe UI,Roboto,Arial}
  h1{max-width:1120px;margin:18px auto 8px;padding:0 16px;font-size:26px}
  .wrap{max-width:1120px;margin:0 auto;padding:16px}
  .grid{display:grid;grid-template-columns:1fr 420px;gap:16px}
  @media (max-width:980px){.grid{grid-template-columns:1fr}}
  .panel{background:var(--panel);border:1px solid var(--borde);border-radius:14px;padding:12px}

  #canvasBox{width:100%;max-width:720px;margin:auto}
  canvas{width:100%;height:auto;display:block;border:1px solid var(--borde);border-radius:10px}

  .row{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  button{background:var(--btn);border:1px solid var(--btnbd);color:var(--txt);border-radius:10px;padding:10px 14px;cursor:pointer}
  button:hover{background:var(--btnh)}
  .primary{background:#2f7d4e;border-color:#2f7d4e}
  input,textarea,select{font:inherit}
  input[type="number"],select{background:#0b1627;border:1px solid var(--borde);border-radius:8px;padding:8px;color:var(--txt)}
  textarea{width:100%;min-height:200px;background:#0b1627;border:1px solid var(--borde);border-radius:10px;padding:10px;color:var(--txt);resize:vertical;white-space:pre-wrap}
  .box{background:#0b1627;border:1px solid var(--borde);border-radius:10px;padding:10px}
  .mono{font-family:ui-monospace,Menlo,Consolas,monospace;white-space:pre-wrap}
  .note{color:var(--muted);font-size:14px}

  .evalbar-wrap{height:14px;border-radius:8px;overflow:hidden;border:1px solid var(--borde);background:linear-gradient(90deg,#3d5a96 0%,#3d5a96 50%,#2d7a3e 50%,#2d7a3e 100%)}
  .evalbar-pointer{position:relative;height:100%}
  .evalbar-pointer::after{content:"";position:absolute;top:-3px;width:2px;height:20px;background:#fff;left:50%;box-shadow:0 0 4px #000a}
</style>

<!-- Reglas PGN/jugadas -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.12.0/chess.min.js"></script>
</head>
<body>
  <h1>Visor PGN — tablero interactivo + análisis</h1>

  <div class="wrap grid">
    <!-- Tablero + controles -->
    <div class="panel">
      <div id="canvasBox"><canvas id="board" width="720" height="720"></canvas></div>

      <div class="row" style="margin-top:12px">
        <button id="prevBtn" title="Anterior">←</button>
        <button id="playBtn" class="primary" title="Play/Pausa">▶</button>
        <button id="nextBtn" title="Siguiente">→</button>
        <button id="resetBtn" title="Reiniciar">Reiniciar</button>
        <label style="margin-left:auto;display:flex;align-items:center;gap:6px">
          <input id="autoChk" type="checkbox" checked> Auto-analizar
        </label>
      </div>

      <div class="row" style="margin-top:8px">
        <label>Velocidad (ms) <input id="speed" type="number" value="800" min="120" step="40" style="width:110px"></label>
        <label>Profundidad
          <select id="depthSel"><option>12</option><option selected>16</option><option>18</option><option>20</option></select>
        </label>
        <label>Líneas
          <select id="linesSel"><option value="1">1</option><option value="2" selected>2</option></select>
        </label>
      </div>

      <div class="note" id="status" style="margin-top:8px">OK: tablero listo. Click o arrastra una pieza para mover.</div>
    </div>

    <!-- Carga PGN + análisis -->
    <div class="panel">
      <div class="row">
        <input id="file" type="file" accept=".pgn,.txt">
        <button id="loadFileBtn" class="primary">Cargar PGN</button>
      </div>
      <div class="note" style="margin:8px 0 6px">O pega un PGN:</div>
      <textarea id="pgnText" placeholder="Pega aquí el texto PGN y pulsa “Cargar desde texto”."></textarea>
      <div class="row" style="margin-top:8px">
        <button id="loadTextBtn" class="primary">Cargar desde texto</button>
        <button id="copyFenBtn">Copiar FEN</button>
      </div>

      <div id="gameInfo" class="note" style="margin-top:10px">Sin partida cargada.</div>
      <div id="movesBox" class="box mono" style="margin-top:6px">Movidas aparecerán aquí…</div>

      <div class="note" style="margin-top:12px">Análisis Stockfish</div>
      <div class="evalbar-wrap" title="Barra de evaluación (−10 … +10)">
        <div id="evalPointer" class="evalbar-pointer" style="left:50%"></div>
      </div>
      <div class="row" style="margin-top:8px">
        <button id="analyzeBtn" class="primary">Analizar posición</button>
        <button id="stopBtn">Detener</button>
      </div>
      <div class="box" id="evalBox" style="margin-top:8px">Eval: — | Profundidad: — | Mejor jugada: —</div>
      <div class="box mono" id="pvBox" style="margin-top:8px">Líneas aparecerán aquí…</div>
    </div>
  </div>

<script>
/* ================== Canvas + dibujo ================== */
const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d',{alpha:true});
const SIZE = 720, S=SIZE/8;
const COLORS = {light:getCss('--sq-a'), dark:getCss('--sq-b')};
const GLYPH = {'P':'♙','N':'♘','B':'♗','R':'♖','Q':'♕','K':'♔','p':'♟','n':'♞','b':'♝','r':'♜','q':'♛','k':'♚'};
function getCss(n){ return getComputedStyle(document.documentElement).getPropertyValue(n).trim(); }
function sqToXY(sq){ const f=sq.charCodeAt(0)-97, r=8-Number(sq[1]); return {x:f*S,y:r*S}; }
function xyToSq(x,y){ const f=Math.floor(x/S), r=Math.floor(y/S); if(f<0||f>7||r<0||r>7) return null; return String.fromCharCode(97+f)+(8-r); }
function centerOf(sq){ const p=sqToXY(sq); return {x:p.x+S/2,y:p.y+S/2}; }

let lastArrows=[], lastMove=null;
let selSq=null, selMoves=[];

function drawBoard(fenPieces, dragging=null){
  // casillas
  for(let r=0;r<8;r++){
    for(let c=0;c<8;c++){
      ctx.fillStyle=((r+c)%2===0)?COLORS.light:COLORS.dark;
      ctx.fillRect(c*S,r*S,S,S);
    }
  }
  // último movimiento
  if(lastMove){
    ctx.fillStyle=getCss('--last');
    [lastMove.from,lastMove.to].forEach(s=>{ if(!s) return; const p=sqToXY(s); ctx.fillRect(p.x,p.y,S,S); });
  }
  // piezas
  const rows=fenPieces.split('/');
  ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.font=`${S*0.72}px "Segoe UI Symbol","Apple Color Emoji","Noto Color Emoji",serif`;

  for(let r=0;r<8;r++){
    let file=0;
    for(const ch of rows[r]){
      if(/\d/.test(ch)){ file+=+ch; continue; }
      const x=(file+0.5)*S, y=(r+0.5)*S;
      // si se está arrastrando esta pieza, se dibuja aparte
      if(dragging && dragging.fromRow===r && dragging.fromCol===file){ file++; continue; }
      drawPieceGlyph(ch,x,y);
      file++;
    }
  }

  // selección + destinos
  if(selSq){
    const {x,y}=sqToXY(selSq); ctx.fillStyle=getCss('--sel'); ctx.fillRect(x,y,S,S);
    ctx.fillStyle=getCss('--dot');
    selMoves.forEach(s=>{ const p=sqToXY(s); ctx.beginPath(); ctx.arc(p.x+S/2,p.y+S/2,S*0.15,0,Math.PI*2); ctx.fill(); });
  }

  // flechas
  lastArrows.forEach((a,i)=>drawArrow(a.from,a.to,i===0?getCss('--arrow1'):getCss('--arrow2')));

  // pieza en “drag”
  if(dragging){
    ctx.globalAlpha=0.9;
    drawPieceGlyph(dragging.ch, dragging.x, dragging.y, true);
    ctx.globalAlpha=1;
  }
}

function drawPieceGlyph(ch,cx,cy,isAbs=false){
  // blanco relleno + trazo oscuro para que se vea sobre claro
  const isWhite=/[PRNBQK]/.test(ch);
  ctx.fillStyle=isWhite?'#ffffff':'#0f0f0f';
  ctx.strokeStyle=isWhite?'#1b2636':'#e8f1e6';
  ctx.lineWidth=S*0.06;
  if(isAbs){ // coordenadas absolutas (arrastre)
    ctx.fillText(GLYPH[ch]||'', cx, cy);
    ctx.strokeText(GLYPH[ch]||'', cx, cy);
  }else{
    ctx.fillText(GLYPH[ch]||'', cx, cy);
    ctx.strokeText(GLYPH[ch]||'', cx, cy);
  }
}

function drawArrow(from,to,color){
  const A=centerOf(from), B=centerOf(to);
  ctx.strokeStyle=color; ctx.lineWidth=10; ctx.lineCap='round';
  ctx.beginPath(); ctx.moveTo(A.x,A.y); ctx.lineTo(B.x,B.y); ctx.stroke();
  const ang=Math.atan2(B.y-A.y,B.x-A.x), L=18;
  ctx.beginPath(); ctx.moveTo(B.x,B.y);
  ctx.lineTo(B.x-L*Math.cos(ang-0.5),B.y-L*Math.sin(ang-0.5));
  ctx.moveTo(B.x,B.y);
  ctx.lineTo(B.x-L*Math.cos(ang+0.5),B.y-L*Math.sin(ang+0.5));
  ctx.stroke();
}

/* ================== Lógica partida ================== */
let game, frames=[], idx=0;
function setStatus(msg){ document.getElementById('status').textContent=msg; }
function initGame(){ if(typeof Chess!=='function'){ setStatus('No se pudo cargar chess.js.'); return false; } game=new Chess(); frames=[game.fen()]; idx=0; render(); return true; }
function currentFen(){ return frames[idx]||game.fen(); }
function currentFenPieces(){ return currentFen().split(' ')[0]; }
function render(){ drawBoard(currentFenPieces()); setStatus(`Posición ${idx}/${frames.length-1}`); }

/* ================== PGN robusto ================== */
function smartDecode(buf){ let txt=new TextDecoder('utf-8',{fatal:false}).decode(buf); if((txt.match(/\uFFFD/g)||[]).length>5){ try{ txt=new TextDecoder('windows-1252').decode(buf);}catch{} } return txt; }
function splitFirstGame(txt){ const m=txt.indexOf('\n\n[Event'); return m>0?txt.slice(0,m):txt; }
function cleanPGN(txt){
  return txt.replace(/^\uFEFF/,'').replace(/\r/g,'\n').replace(/[\u2026]/g,'...')
            .replace(/\$[0-9]+/g,' ').replace(/\{[^}]*\}/g,' ').replace(/\([^)]*\)/g,' ')
            .replace(/[^\x09\x0A\x0D\x20-\x7E]/g,' ').replace(/\s+/g,' ').trim();
}
function tryLoadPGN(raw){
  const one=splitFirstGame(raw); const cleaned=cleanPGN(one);
  const ok=game.load_pgn(cleaned,{sloppy:true});
  if(!ok){ alert('PGN inválido.'); }
  return ok;
}
async function loadPGNFromFile(file){
  try{ const buf=await file.arrayBuffer(); const txt=smartDecode(buf); game.reset(); if(!tryLoadPGN(txt)) return; afterLoaded(); }
  catch{ alert('Error leyendo el archivo PGN.'); }
}
function loadPGNFromText(text){ game.reset(); if(!tryLoadPGN(text)) return; afterLoaded(); }
function afterLoaded(){
  const san=game.history(); frames=[game.fen()]; game.reset(); frames=[game.fen()];
  for(const mv of san){ const m=game.move(mv); frames.push(game.fen()); lastMove={from:m.from,to:m.to}; }
  idx=frames.length-1; selSq=null; selMoves=[]; lastArrows=[];
  updateListFromFrames(); render(); if(autoOn()) triggerAnalyze();
}
function updateListFromFrames(){
  // reconstruir SAN a partir de frames
  const movesSAN=[]; let prev=new Chess(); prev.load(frames[0]);
  for(let i=1;i<frames.length;i++){
    const cur=new Chess(); cur.load(frames[i]);
    const legal=prev.moves({verbose:true});
    const played=legal.find(m=>{ const t=new Chess(); t.load(prev.fen()); t.move(m); return t.fen()===cur.fen(); });
    if(played){ movesSAN.push(played.san); prev=cur; }
  }
  document.getElementById('movesBox').textContent=movesSAN.map((m,i)=>(i%2===0? (Math.floor(i/2)+1)+'. ':'')+m).join(' ');
  document.getElementById('gameInfo').textContent=`Movidas: ${movesSAN.length}`;
}

/* ================== Controles navegación ================== */
document.getElementById('prevBtn').onclick = ()=>{ if(idx>0){ idx--; lastArrows=[]; render(); if(autoOn()) triggerAnalyze(); } };
document.getElementById('nextBtn').onclick = ()=>{ if(idx<frames.length-1){ idx++; lastArrows=[]; render(); if(autoOn()) triggerAnalyze(); } };
document.getElementById('resetBtn').onclick = ()=>{ idx=0; lastArrows=[]; render(); if(autoOn()) triggerAnalyze(); };

let timer=null;
document.getElementById('playBtn').onclick = ()=>{
  if(timer){ clearInterval(timer); timer=null; return; }
  const ms=Math.max(120,+document.getElementById('speed').value||800);
  timer=setInterval(()=>{ if(idx<frames.length-1){ idx++; lastArrows=[]; render(); if(autoOn()) triggerAnalyze(); } else { clearInterval(timer); timer=null; } }, ms);
};

/* ================== Cargar/copy ================== */
document.getElementById('loadFileBtn').onclick=async()=>{
  const f=document.getElementById('file').files?.[0]; if(!f){ alert('Selecciona un archivo .pgn'); return; }
  await loadPGNFromFile(f);
};
document.getElementById('loadTextBtn').onclick=()=> loadPGNFromText(document.getElementById('pgnText').value);
document.getElementById('copyFenBtn').onclick=async()=>{ await navigator.clipboard.writeText(currentFen()); setStatus('FEN copiado.'); };
function autoOn(){ return document.getElementById('autoChk').checked; }

/* ================== Interacción: click + arrastrar ================== */
function sideToMoveFen(fen){ return fen.split(' ')[1]; }
function legalTargetsFromFen(fen,sq){ try{ const ch=new Chess(); ch.load(fen); return ch.moves({square:sq, verbose:true}).map(m=>m.to);}catch{return [];} }
function getPieceCharAtFen(fen,sq){
  const ch=new Chess(); ch.load(fen); const p=ch.get(sq); if(!p) return null;
  const map={p:'p',n:'n',b:'b',r:'r',q:'q',k:'k'}; const g=map[p.type]; return p.color==='w'?g.toUpperCase():g;
}

let dragging=null; // {from, fromRow, fromCol, ch, x, y}

function selectSquare(sq){
  const fen=currentFen(); const ch=new Chess(); ch.load(fen); const piece=ch.get(sq);
  if(!piece || piece.color!==sideToMoveFen(fen)[0]){ selSq=null; selMoves=[]; render(); return; }
  selSq=sq; selMoves=legalTargetsFromFen(fen,sq); render();
}
function tryMove(to,fromSel=null,promoHint){
  const fen=currentFen(); const ch=new Chess(); ch.load(fen);
  const from = fromSel || selSq; if(!from) return false;
  let moveObj={from,to};
  const piece=ch.get(from);
  const isPromotion=piece && piece.type==='p' && (to.endsWith('8')||to.endsWith('1'));
  if(isPromotion){ const p=promoHint || prompt('Promoción: q,r,b,n (Dama por defecto)','q')||'q'; moveObj.promotion=/[qrbn]/i.test(p)?p.toLowerCase():'q'; }
  const mv=ch.move(moveObj);
  if(mv){
    frames=frames.slice(0,idx+1); frames.push(ch.fen()); idx=frames.length-1; lastMove={from:mv.from,to:mv.to};
    selSq=null; selMoves=[]; lastArrows=[]; updateListFromFrames(); render(); if(autoOn()) triggerAnalyze(); return true;
  }else{ selSq=null; selMoves=[]; render(); return false; }
}

// Click-to-move
function onTap(ev){
  const rect=canvas.getBoundingClientRect();
  const x=(ev.clientX-rect.left)*canvas.width/rect.width;
  const y=(ev.clientY-rect.top )*canvas.height/rect.height;
  const sq=xyToSq(x,y); if(!sq) return;
  if(!selSq){ selectSquare(sq); }
  else if(sq===selSq){ selSq=null; selMoves=[]; render(); }
  else { tryMove(sq); }
}
canvas.addEventListener('click', onTap);

// Drag & drop
function evtPos(e){ const r=canvas.getBoundingClientRect(); const c=(e.touches?e.touches[0]:e); return {x:(c.clientX-r.left)*canvas.width/r.width, y:(c.clientY-r.top)*canvas.height/r.height}; }
function onDown(e){
  const {x,y}=evtPos(e); const sq=xyToSq(x,y); if(!sq) return;
  const fen=currentFen(); const pieceChar=getPieceCharAtFen(fen,sq);
  if(!pieceChar) return;
  const side=sideToMoveFen(fen); const isWhite=/[A-Z]/.test(pieceChar);
  if((side==='w' && !isWhite) || (side==='b' && isWhite)) return;

  const c=sq.charCodeAt(0)-97, r=8-Number(sq[1]);
  selSq=sq; selMoves=legalTargetsFromFen(fen,sq);
  dragging={from:sq, fromRow:r, fromCol:c, ch:pieceChar, x, y};
  drawBoard(currentFenPieces(), dragging);
  e.preventDefault();
}
function onMove(e){
  if(!dragging) return;
  const {x,y}=evtPos(e); dragging.x=x; dragging.y=y;
  drawBoard(currentFenPieces(), dragging);
  e.preventDefault();
}
function onUp(e){
  if(!dragging) return;
  const {x,y}=evtPos(e);
  const drop=xyToSq(x,y);
  const from=dragging.from;
  dragging=null;
  if(drop && drop!==from) { tryMove(drop, from); }
  else { selSq=null; selMoves=[]; render(); }
  e.preventDefault();
}
canvas.addEventListener('mousedown', onDown);
canvas.addEventListener('mousemove', onMove);
window.addEventListener('mouseup', onUp);
canvas.addEventListener('touchstart', onDown, {passive:false});
canvas.addEventListener('touchmove', onMove, {passive:false});
canvas.addEventListener('touchend', onUp, {passive:false});

/* ================== Stockfish ================== */
let engine=null,lastAnalyzeAt=0, analyzing=false, latest={depth:0,pv:{}};
const MIRRORS=[
  'https://cdnjs.cloudflare.com/ajax/libs/stockfish.js/9.0.0/stockfish.js',
  'https://raw.githubusercontent.com/niklasf/stockfish.js/gh-pages/src/stockfish.js'
];
function ensureEngine(){
  if(engine) return engine;
  const boot=`self.onerror=function(){};let ok=false;const urls=${JSON.stringify(MIRRORS)};(async()=>{for(const u of urls){try{importScripts(u);ok=true;postMessage({type:'_loaded',src:u});break}catch(e){}}if(!ok)postMessage({type:'sf-error',msg:'Mirrors fallaron'});})();`;
  engine=new Worker(URL.createObjectURL(new Blob([boot],{type:'application/javascript'})));
  engine.onmessage=onEngineMsg; return engine;
}
function resetLatest(){ latest={depth:0,pv:{}}; }
function onEngineMsg(e){
  const d=typeof e.data==='string'? e.data : e.data;
  if(d && d.type==='sf-error'){ document.getElementById('pvBox').textContent='No se pudo cargar Stockfish (mirrors).'; return; }
  const line=typeof d==='string'? d : '';
  if(!line) return;
  if(line.startsWith('info ')){
    const depth=getNum(line,/\bdepth\s+(\d+)/); if(depth) latest.depth=Math.max(latest.depth,depth);
    const multipv=getNum(line,/\bmultipv\s+(\d+)/)||1;
    const cp=getNum(line,/\bcp\s+(-?\d+)/); const mate=getNum(line,/\bmate\s+(-?\d+)/);
    const pv=(line.match(/\bpv\s+(.+)/)||[])[1]||''; const score=(mate!=null)?{mate}:{cp};
    if(pv){ latest.pv[multipv]={pv,score}; refreshEvalPanel(); }
  }
  if(line.startsWith('bestmove')) analyzing=false;
}
function getNum(s,re){ const m=s.match(re); return m?Number(m[1]):null; }
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }
function scoreToEvalText(sc){ if(sc.mate!=null) return '#'+sc.mate; if(sc.cp!=null) return (sc.cp/100).toFixed(2); return '—'; }
function updateEvalBar(sc){ let cp=sc.mate!=null?(sc.mate>0?1000:-1000):(sc.cp??0); const p=(clamp(cp,-1000,1000)+1000)/2000; document.getElementById('evalPointer').style.left=(p*100)+'%'; }
function pvUciToSAN(fen,uci){ const ch=new Chess(); ch.load(fen); const ms=uci.trim().split(/\s+/); const out=[]; for(const u of ms){ const from=u.slice(0,2),to=u.slice(2,4),prom=u[4]; const m=ch.moves({verbose:true}).find(x=>x.from===from&&x.to===to&&(!prom||x.promotion===prom)); if(!m) break; out.push(m.san); ch.move(m);} return out.join(' '); }
function firstMoveFromUci(uci){ const m=uci.trim().split(/\s+/)[0]||''; return {from:m.slice(0,2),to:m.slice(2,4)}; }
function refreshEvalPanel(){
  const pv1=latest.pv[1], pv2=latest.pv[2]; const fen=currentFen(); let text=''; lastArrows=[];
  if(pv1){ const san1=pvUciToSAN(fen,pv1.pv); text+=`① ${san1}\n`; updateEvalBar(pv1.score); showEval(scoreToEvalText(pv1.score),latest.depth,(san1.split(' ')[0]||'—')); const m1=firstMoveFromUci(pv1.pv); if(m1.from) lastArrows.push(m1); }
  if(pv2){ const san2=pvUciToSAN(fen,pv2.pv); text+=`② ${san2}\n`; const m2=firstMoveFromUci(pv2.pv); if(m2.from) lastArrows.push(m2); }
  document.getElementById('pvBox').textContent=text||'Pensando…'; render();
}
function showEval(ev,depth,best){ document.getElementById('evalBox').textContent=`Eval: ${ev} | Profundidad: ${depth||'—'} | Mejor jugada: ${best||'—'}`; }
function triggerAnalyze(){
  const now=performance.now(); if(now-lastAnalyzeAt<900) return; lastAnalyzeAt=now;
  ensureEngine(); analyzing=true; resetLatest();
  const depth=+document.getElementById('depthSel').value||16;
  const mpv=+document.getElementById('linesSel').value||2;
  const fen=currentFen();
  document.getElementById('pvBox').textContent='Pensando…';
  engine.postMessage('uci'); engine.postMessage('isready'); engine.postMessage('ucinewgame');
  engine.postMessage(`setoption name MultiPV value ${mpv}`);
  engine.postMessage(`position fen ${fen}`); engine.postMessage(`go depth ${depth}`);
}
document.getElementById('analyzeBtn').onclick=()=>triggerAnalyze();
document.getElementById('stopBtn').onclick=()=>{ if(engine) engine.postMessage('stop'); analyzing=false; };

/* ================== Init ================== */
window.addEventListener('load', ()=>{ if(initGame()){ render(); }});
</script>
</body>
</html>
